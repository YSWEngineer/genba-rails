# Chapter 1 Rails のための Ruby 入門
<details><summary>Chapter 1 - 1 オブジェクトを理解しよう</summary>
	
### 1 - 1 - 1 万物がオブジェクト
- Ruby や Ruby on Rails を理解する上で、いちばんの基礎となるのが「オブジェクト」という概念です。
- 「オブジェクト」とは、簡単に言うと「モノ」のようなものです。
- Ruby の世界には、大小のオブジェクトが関わり合いながら存在しています。
    - 別の言い方をすると、Ruby は「オブジェクトを作ったり使ったりすることで、コンピューターにプログラマの望んだ仕事(処理)を行わせる言語」です。
- Ruby の世界の中の「オブジェクト」と見分けて、どのオブジェクトがどんな仕事を担当するのかをイメージできるようになることが大切です。
- Ruby on Rails と使って Webアプリケーションを書くということは、Rails の用意したフレームワークを理解して、その上でプログラムを書くということでもあります。


### 1 - 1 - 2 irb
- Ruby には、irb (アイアールビー)という、対話的な実行環境が付属しています。


### 1 - 1 - 3 文字列
- Webアプリケーションにおいてもっとも基本的なオブジェクトの一つが「文字列」です。
- 文字列とは、「氏名」「酒類の購入には年齢記入が必要です」といった、人間が読むことのできる文字や記号で構成された単語や文章のようなデータのことを指します。
- 文字列オブジェクトを作る一番簡単な方法は、ダブルクォーテーション(”)で内容を囲むことです。たとえば、`”氏名”`のように書きます。
- 文字列オブジェクトを作るためには、シングルクォーテーション(’)を使うこともできます。


### 1 - 1 - 4 数値
- プログラムを作る上では、数値も重要です。
- 数値とは、 1 や 100 のように、数を表すオブジェクトです。
- Ruby では数値もオブジェクトに含まれます。


### 1 - 1 - 5 オブジェクトに、自分が何者かを聞いてみる
- 全てのオブジェクトには、自分の型を持っていて、この型のことを「クラス」と呼びます。
- クラスを尋ねるには、オブジェクトの後に `.class` という記述をします。

```bash
irb(main):001:0> "氏名".class
=> String # String(文字列)
```

```bash
irb(main):002:0> 1.class
=> Integer # Integer(整数)
```

- オブジェクトは全てが object_id という固有の番号を持っています。
    
```bash
irb(main):001:0> "氏名".object_id
=> 11300
irb(main):002:0> 1.object_id
=> 3
irb(main):003:0> "氏名".object_id
=> 27880
irb(main):004:0> 1.object_id
=> 3
```
    
- “氏名” という Rubyコードに対応して用意される文字列オブジェクトは、Rubyコードが実行されるたびに、別のオブジェクトが作られる。
- 1というRubyコードに対応して用意される数値オブジェクトは、何回 1 というRubyコードを実行しても、同じ数値オブジェクトが提供される。


### 1 - 1 - 6 クラスとインスタンス
- Rubyのようなオブジェクト指向言語では、一般的に「オブジェクト X のクラスが A であるとき、X は A のインスタンス(オブジェクト)である」といいます。
- インスタンスオブジェクトは「インスタンス」、「オブジェクト」と呼ばれることもありますが、オブジェクトそのもの、という意味で使われます。


### 1 - 1 - 7 オブジェクトの機能はクラスで決まる
- オブジェクトにどんな仕事をさせることができるのかは、そのオブジェクトがどんなクラスのオブジェクトであるかによります。
- オブジェクトの機能はクラスによって異なるので、Ruby でプログラムを作るためには、どんなクラスのオブジェクトにどんな機能があるのかを知り、目的にあったクラスのオブジェクトを使うことが大切になってきます。


### 1 - 1 - 8 変数
- 変数は、何かのオブジェクトを指し示すことができる、ラベルのような存在です。変数にわかりやすい名前を付けて使うことで、プログラムを格段にわかりやすくすることができます。
- 変数を通じてオブジェクトを参照できるようにすることを「代入する」と呼びます。代入するには、= を使います。
- Ruby のローカル変数の名前は、アルファベットの小文字かアンダースコア( _ )で始めます。2 文字目以降には、大文字や数字も利用できます。慣習としては、単語の区切りにアンダースコア( _ )を使うスネークケースという記法で変数の名前を付けることが好まれています。


| よく見かける記法 | 文法的にはあっているが、一般的でない記法 | ローカル変数として解析できない記法 |
| --- | --- | --- |
| sample_message | sampleMessage (キャメルケース) | SampleMessage |
| part2 | パート2 | 2part |
| _user | _USER | -user |

- なお、アルファベットの大文字から始まる名前は、保持する値が不変の「定数」と解釈されます。厳密には、Ruby の定数の値は絶対に変更できないわけでなく、warningメッセージが出力されるものの、再定義することも可能となっています。


### 1 - 1 - 9 コメント
- Ruby のプログラムの中に、任意のコメントを記述することができます。コメントは、ソースコードの内容を補完するドキュメンテーションなどの用途で便利に利用できます。
- いくつか書き方はありますが、基本的なのが # のあとにコメントを記述する方法です。


### 1 - 1 - 10 メソッド
- オブジェクトの代表的な仕事は、何らかの振る舞いをすることです。Ruby のオブジェクトの振る舞いは、基本的に「メソッド」として記述します。
    - メソッドには「(〜を)…します」というような内容を記述することになります。

```ruby
タマ.追いかける(ネズミ) 
# 「追いかける」がメソッドに相当します。
# インスタンスに対して呼び出せるメソッドをインスタンスメソッドと呼びます。
```

- インスタンスに対して呼び出せるメソッドをインスタンスメソッドと呼びます。

```ruby
class 猫
  def 追いかける(ネズミ)
	puts "一生懸命 #{ネズミ} を追いかけた..." # 画面にメッセージを出力します。
  end
end

タマ = 猫.new
# 「追いかける」の部分がメソッド、(ネズミ)の部分がメソッドに対して補足的な情報を与える「引数」と呼ばれるものになります。
```

- 「追いかける」の部分がメソッド、(ネズミ)の部分がメソッドに対して補足的な情報を与える「引数」と呼ばれるものになります。
- オブジェクトにドット( . )を付け、その後にメソッドの名前を記述することでメソッドを呼び出すことができます。

```ruby
# フォームから入力されたデータが変数に入っている状態を作ります。
message = '先ほど注文した商品を全て一旦キャンセルさせてください'

# エラーメッセージの表示を行います。
if message.length > 100
  puts 'メッセージは100文字以下で入力してください。'
end
```

- 先の lengthメソッドの呼び出し例では、message がレシーバとなっています。
- Stringクラスのオブジェクトには、 concat という、**自分に別の文字列オブジェクトを結合させるメソッド**があります。

```ruby
irb(main):005:0> message1 = "こんにちは。"
=> "こんにちは。"
irb(main):006:0> message2 = "こんばんは。"
=> "こんばんは。"
irb(main):007:0> message1.concat(message2)
=> "こんにちは。こんばんは。"
irb(main):008:0> message1
=> "こんにちは。こんばんは。"
irb(main):009:0> message2
=> "こんばんは。"
```

- concatメソッドは 2 つ以上のオブジェクトを同時に結合することができます。2 つ以上のオブジェクトを同時に結合したいときは、結合したいオブジェクトを全てをメソッドに引数として渡します。メソッドに渡すオブジェクトは、引数ごとにカンマ( , )で区切ります。

```ruby
irb(main):011:0> message1 = "おはようございます。"
=> "おはようございます。"
irb(main):012:0> message2 = "こんにちは。"
=> "こんにちは。"
irb(main):013:0> message3 = "こんばんは。"
=> "こんばんは。"
irb(main):014:0> message1.concat(message2, message3)
=> "おはようございます。こんにちは。こんばんは。"
```

- 引数を付けるメソッドには必ず括弧を付けていました。しかし、実は**括弧を省略してメソッド呼び出しを書く**こともできます。括弧を省略する時は、メソッド名と引数の間に半角スペースを入れます。

```ruby
irb(main):015:0> message1 = "おはようございます。"
=> "おはようございます。"
irb(main):016:0> message2 = "こんにちは。"
=> "こんにちは。"
irb(main):017:0> message3 = "こんばんは。"
=> "こんばんは。"
irb(main):018:0> message1.concat message2,message3
=> "おはようございます。こんにちは。こんばんは。"
```

- 括弧を省略しない書き方、省略した書き方、どちらの書き方も実際のコードを読んでいて見掛けることがあります。慣れるまでは大変かもしれませんが、どちらの書き方も知っておくと便利です。
    - なお、引数を渡す必要がないメソッドを length( ) のように空の括弧に付けて呼び出すこともできますが、Rubyプログラマの間では、length のように括弧を付けない書き方が主流と言えそうです。</details>


<details><summary>Chapter 1 - 2 自分でクラスを作ってみよう</summary>
	
### 1 - 2 - 1 クラスを作る
- Ruby on Rails で Webアプリケーションを作る場合には、プログラマがクラスを作成する必要があるため、クラスを作ることについての知識は欠かせません。


### 1 - 2 - 2 Userクラスを作る
- ユーザーを表すクラスを作成します。

    1\. user.rbフォルダを作成する。
    
    2\. エディターを開いて、user.rb フォルダから user.rbファイルを作成する。
    
    3\. user.rbファイルに、User という名前のクラスを作成する。

```ruby
# エディターに User という名前のクラスを作成する。
class User
end
```

```ruby
# require を使って user.rb を読み込みます。
irb(main):001:0> require './user.rb'
=> true

# クラスの名前の後に .new と記述して、オブジェクトを作成します。
irb(main):002:0> user = User.new
=> #<User:0x000000010a623fd0>

# Userクラスのオブジェクトが作られたかどうか、レシーバのクラス名を返すclassメソッドを使って、確認します。
irb(main):003:0> user.class
=> User # user はUserクラスのオブジェクトになっています。
```

### 1 - 2 - 3 Userクラスにメソッドを定義する
- 作成したUserクラスから name というメソッドを作成します。

```ruby
# エディター
class User
  def name
  end
end

# irb
irb(main):001:0> require './user.rb'
=> true
irb(main):002:0> user = User.new
=> #<User:0x000000010b31d970>
irb(main):003:0> user.name
=> nil
```

- nil は Ruby において「無い」ことを表すオブジェクトです。nameメソッドは空っぽなので、nil が返ってきています。
- メソッドが呼ばれたときに返ってくる値のことを「返り値(または戻り値)」と呼びます。Ruby では、return を使って明示的に指定された値や、メソッド内で最後に評価された値がメソッドの返り値となります。どちらを使っても構いませんが、一般的には、メソッドの途中でメソッドを抜けたい場合には return を使い、メソッドの最後で返り値を指定する場合は return を使わないことが多いでしょう。
- たとえば、どんなユーザーの name も”匿名さん”を返すようにしたい場合は、nameメソッドの実装は次のようになります。

```ruby
# return を使う場合
class User
  def name
    return "匿名さん"
  end
end

# return を使わない場合
class User
  def name
     "匿名さん"
  end
end
```

- どちらの書き方でも、次のように、Userクラスのオブジェクトでnameメソッドの返り値として「匿名さん」という文字列を得ることができます。

```ruby
irb(main):002:0> user = User.new
=> #<User:0x0000000112cf3b00>
irb(main):003:0> user.name
=> "匿名さん"
```

- 実際には、すべてのUserオブジェクトが同じ名前を持つように実装することはほとんどないでしょう。ログインしてきたユーザーそれぞれの名前を保持するようにしたいはずです。オブジェクトごとに異なるデータを保持できるようにするためには、「インスタンス変数」を使います。


### 1 - 2 - 4 インスタンス変数
- インスタンス変数は、オブジェクトが抱えている変数です。インスタンス変数に代入したデータは、インスタンス変数を抱えているオブジェクトが存在する限り、オブジェクトともに存在し続けます。インスタンス変数は、オブジェクトのメソッドの中から利用可能な一方で、オブジェクトの外側から直接利用することは基本的にできません。インスタンス変数の名前の先頭には必ず＠(アットマーク)を付けます。

```ruby
class User
  def name=(name)
    @name = name
  end

  def name
    @name
  end
end
```

- ここでは「name=」という名前を設定するメソッドを追加しました。**Ruby では末尾に=という記号がついたメソッド名を定義することで、属性をオブジェクトにセットするような形のメソッドを作ることができます。**name=メソッドでは、引数で受け取ったデータをインスタンス変数 @name に代入します。このような、インスタンス変数を代入するためのメソッドをセッターと呼ぶことがあります。
- また、nameメソッドの中身を変更して、設定した名前(@name)を返すようにしています。このような、インスタンス変数の内容を参照するためのメソッドをゲッターと呼ぶことがあります。
- 新しいUserクラスの動作を確認してみましょう。

```ruby
irb(main):002:0> user = User.new
=> #<User:0x0000000107d89a70>
irb(main):003:0> user.name = "小田井優"
=> "小田井優"
```

- 上記では、名前の文字列をuserオブジェクトに設定しました。続いて、userオブジェクトの状態を見てみましょう。**irb 上でオブジェクトを評価すると、そのオブジェクトのinspectメソッドが呼ばれます。**

```ruby
irb(main):004:0> user
=> #<User:0x0000000107d89a70 @name="小田井優"> # userオブジェクトがinspectメソッドで出力されます。
```

- 設定した名前をuserオブジェクトが「抱えている」様子がわかります。次に、nameメソッドを使って名前を取得してみましょう。

```ruby
irb(main):005:0> user.name
=> "小田井優"
```

- これで、オブジェクトごとに異なる名前を保持することができるようになったので、複数のオブジェクトにそれぞれ違う名前を設定してみましょう。

```ruby
irb(main):007:0> user1 = User.new
=> #<User:0x0000000107d51080>
irb(main):008:0> user1.name = "大場寧子"
=> "大場寧子"

irb(main):009:0> user2 = User.new
=> #<User:0x0000000107d236f8>
irb(main):010:0> user2.name = "小芝美由紀"
=> "小芝美由紀"

irb(main):011:0> user1.name
=> "大場寧子"

irb(main):012:0> user2.name
=> "小芝美由紀"
```

- 無事、オブジェクトごとに別々の名前を入れて扱うことができるようになりました。


### 1 - 2 - 5 ローカル変数とインスタンス変数の違い
- user のようなローカル変数と @name のようなインスタンス変数は、代入の仕方や参照の仕方は同じですが、次のような違いがあります。
- たとえば、自分で作った次のMyClassクラスが存在するとします。

```ruby
class MyClass
  def method_1
    number = 100
  end

  def method_2
    number
  end
end
```

- このクラスのオブジェクトを作って、method_1メソッドを呼び出してみます。

```ruby
irb(main):014:0> object = MyClass.new
=> #<MyClass:0x0000000107df8218>
irb(main):015:0> object.method_1
=> 100
```

- このメソッドは number というローカル変数に 100 という数値のオブジェクトを入れており、ローカル変数に入れたオブジェクトを返り値としています。
- 続けて、method_2メソッドを呼び出してみます。

```ruby
irb(main):016:0> object.method_2
/Users/yoshiwo/Desktop/user.rb/user.rb:7:in `method_2': undefined local variable or method `number' 
for #<MyClass:0x0000000107df8218> (NameError)
```

- method_1で定義した number というローカル変数が method_2 でも生き残っていれば 100 と表示されるはずです。エラーが返ってきてしまったということは、method_2 では method_1 で使った number を使えない状態だということです。
- それでは、number というローカル変数ではなく、インスタンス変数 @number を使うようにするとどうなるでしょうか。

```ruby
# インスタンス変数 @number を使用。
class MyClass
  def method_1
    @number = 100
  end

  def method_2
    @number
  end
end

irb(main):021:0> object = MyClass.new
=> #<MyClass:0x0000000107bd9310>
irb(main):022:0> object.method_1
=> 100
irb(main):023:0> object.method_2
=> 100
```

- エラーが出ずに、無事に 100 という値が返ってきました。method_1 と method_2 が、同じ @number という変数を利用できていることがわかります。
- ローカル変数とインスタンス変数の違いの理解は、Railsアプリケーションを作成する上でも非常に重要になります。ローカル変数は 1 つのメソッドの中で一時的に使うデータを参照するために使います。一方、インスタンス変数は、特定のオブジェクトの内部で使い回したり、そのオブジェクトに属するデータとして外部からゲッターを通じて利用させるために用います。ここでは、**インスタンス変数はオブジェクトに抱えられたデータである**というイメージを覚えておいてください。


### 1 - 2 - 6 属性
- 一般的にオブジェクトの抱えるデータのことを「属性(Attribute)」と呼ぶことがあります。先程の例で言えば、name は user の属性ということになります。インスタンス変数も、オブジェクトの抱えるデータのことですから、属性とインスタンス変数はとてもよく似た概念と言えます。ただし、必ずしも同じではありません。インスタンス変数という用語が Ruby の言語の機能を指しているのに対して、属性という用語はもう少し抽象的に、結果としてオブジェクトに対して読んだり書いたりできる(時には片方しかできない)データを表す概念です。
    
    たとえば、外部から見たときには属性として使わないような、オブジェクト内の”秘密の”インスタンス変数が存在する場合もあります。また、外部の記憶装置などを直接使ったり、固定値や、計算値を用いることで、インスタンス変数を使わないで属性を実現することもできます。
    
    Railsアプリケーションにおいては、特にモデル層でこの「属性」という用語が登場します。Railsモデルの「属性」にはデータベースのカラムとの対応関係などの要素が加わるため、より複雑になりますが、根本的な意味としてはオブジェクトが抱えるデータであることに変わりはありません。「属性」という用語にぜひ慣れておきましょう。


### 1 - 2 - 7 ゲッターやセッターを簡単に定義する
- 先程は、Userクラスに属性の name のゲッターとセッターを次のように定義していました。

```ruby
class User
  def name=(name)
    @name = name
  end

  def name
    @name
  end
end
```

- ゲッターやセッターの書き方はいつも同じようになり、上記コードの name のところを別の属性名に変えて、機械的に記述することができます。
- 実は Ruby には、このような機械的なコードをプログラマが書かなくても済むように、**attr_accessor** という便利なメソッドが用意されています。先程のコードは attr_accessor を使って次のように書くことができます。

```ruby
class User
	attr_accessor :name
end
```

- ここで渡している :name という部分は、シンボルです。ここでは名前の先頭に : を付けたものがシンボルという存在であるということを覚えておいてください。
    
    なお、attr_readerを使うとゲッターだけ、attr_writerを使うとセッターだけを定義することができます。


### 1 - 2 - 9 メソッドからメソッドを使う

- オブジェクトのメソッドの中から、同じオブジェクトの他のメソッドを呼び出すことができます。例として、名前と住んでいる場所を合わせて返すようなprofileメソッドを作ってみましょう。

```ruby
class User
  attr_accessor :name, :address, :email

  def profile
    "#{name} (#{address})"
  end
end
```

- `"#{name} (#{address})"` という書き方は見慣れないかもしれません。ダブルクォーテーションで囲んで文字列を作成する際に、#{ } という表記の中でRubyコードを実行し、結果をその位置に埋め込むことができます。

```ruby
irb(main):029:0> user = User.new
=> #<User:0x0000000107cebb18>
irb(main):030:0> user.name = "小田井優"
=> "小田井優"
irb(main):031:0> user.address = "東京"
=> "東京"
irb(main):032:0> user.profile
=> "小田井優 (東京)"
```

- profile というメソッドの内部で、同じオブジェクトの別のメソッドである name や address を呼び出すことができました。
- 因みに、シングルクォーテーションを使って同様の埋め込みはできません。次の実行例で示すように、#{ などがそのまま文字の一部として扱われてしまいます。

```ruby
irb(main):033:0> name = "小田井優"
=> "小田井優"
irb(main):034:0> "#{name}"
=> "小田井優"
irb(main):035:0> '#{name}'
=> "\#{name}"
```

- Ruby に慣れていないうちは、メソッド内での name や address が、メソッドの呼び出しなのか、ローカル変数なのか、どちらなのかわからなくて混乱するかもしれません。見分け方としては、**コード内に出てきた名前がローカル変数として定義されていたり、メソッドの引数になっていればローカル変数、そうでなければメソッド名だと判断**できます。
- 1 つ 1 つのメソッドを長大にせず、引数や変数名を妥当につけていけば、実際にコードを読み書きしていて困ることはあまりないと思います。また、**IDE** では変数やメソッドの文字を自動で色分けしてくれるため、簡単に把握することもできます。

### 1 - 2 - 10 まとめ - オブジェクトの振る舞いとデータ

- これまで、Rubyプログラムを構成する最も基本的な単位が「オブジェクト」であり、「オブジェクト」は「クラス」から作られること、「メソッド」や「インスタンス変数」を抱えることを学んできました。
- 大雑把に言えば、Ruby ではオブジェクトのデータが「インスタンス変数」、振る舞いが「(インスタンス)メソッド」に当たります。そして、どういう種類のインスタンス変数を持つか、それぞれのメソッドの処理が具体的にどのようであるかということを「クラス」に定義しておいて、その定義を使って、同じ性質を持つ「(インスタンス)オブジェクト」を好きなだけ量産して利用していくということになります。
- クラス、オブジェクト、メソッド、インスタンス変数の理解は特に重要なので、よく覚えておきましょう。</details>


<details><summary>Chapter 1 - 3 Rubyプログラムの基礎知識</summary>

ここからは、メソッドを書くといった Ruby でのプログラミングの際によく利用する基本的な Ruby の記法や機能を紹介していきます。

### 1 - 3 - 1 演算子

| 記号 | 意味 |
| --- | --- |
| + | 加算 ・数値を足す ・文字列の連結 ・配列の連結 |
| - | 減算 ・数値を引く ・配列から一部の要素を削除 |
| * | 乗算 ・数値をかける ・文字列を繰り返し連結 ・配列を繰り返し連結 |
| / | 除算 ・数値で割る |
| % | 剰余 ・数値で割った余りを得る |
| || または or | OR演算 |
| && または and | AND演算 |
| ^ | XOR演算 |
| ! または not | 真偽を裏返す(否定) |
| = | 代入 |
| == | 等しいか調べる |
| != | 等しくないか調べる |
| >, >=, <, <= | それぞれ、左辺が大きい、左辺が右辺以上、右辺が大きい、右辺が左辺以上であるかを調べる |
- 数値の演算をするRubyコードの例を挙げておきましょう。

```ruby
irb(main):036:0> result = 1 + 2 * 4 / 8
=> 2
```

- 掛け算や割り算は、足し算や引き算よりも先に評価されるため、上のコードでは 2 という結果が得られます。

### 1 - 3 - 2 nil

- 空っぽのような状態であることを表す「nil」というオブジェクトがあります。nil と書けばいつでも使えます。

```ruby
value = nil
```

- オブジェクトが nil であるかを、nil? というメソッドで調べることができます。

```ruby
irb(main):039:0> value = nil
=> nil
irb(main):040:0> value.nil?
=> true
```

### 1 - 3 - 3 真偽

- if などの条件分岐では、条件が真である(当てはまる)か、それとも偽である(当てはまらない)かで、どのプログラムコードを実行するかを制御します。条件が真であるということはどういうことでしょうか。
- 直感的にわかりやすいのは、次のような例です。

```ruby
value = 3
if value == 3
  # valueが3のとき、ここを実行します。
end
```

- value という変数の値は 3 ですから、「value == 3」は真であるということになります。
- 真か偽という結果は、== などの実行結果だけではなく、オブジェクトそのものを評価しても得られます。

```ruby
value = 3
if value
  # valueが真のとき、ここを実行します。
end
```

- 上記のコードでは、value の値は 3 ですが、これは Ruby では「真」であると解釈されます。
- 真か偽かをわかりやすく示したい場合、Ruby では **true** と **false** というオブジェクトがあり、いつでも利用できます。**true は真、false は偽を表すオブジェクト**です。

```ruby
value = true
if value
  # valueが真のとき、ここを実行します。
end
```

- Ruby では、**nil と false が偽**、それ以外が真となります。
- プログラミング言語の中には 0 が偽である言語もありますが、**Ruby では 0 も真になる**ので注意しましょう。

```ruby
value = 0
if value
  # ここを通ります！
end
```

- nil? を使う例と、偽かどうかを調べている例を挙げておきます。

```ruby
# nil? を使う例
return if value.nil? # value が nil なら以降の処理をしない。

# 偽かどうかを調べている例
return if !value # value が nil もしくは false なら以降の処理をしない。
```

### 1 - 3 - 4 条件分岐

- if の後に条件式を記述して、その条件が真と評価された時にその下の節の処理を実行します。もし、if の条件式が偽だと評価された時は、elseif の条件の評価に進みます。elsif は無くてもよいし、複数記述しても構いません。if と elsif の条件式が全て偽であった時は、else の処理を実行します。else は無くても構いません。最後に「end」でif構造を閉じます。

```ruby
number = 1
if number == 1
  puts '数値は1です'
elsif number == 2
  puts '数値は2です'
else
  puts '数値は1や2以外です'
end

# number == 1 が真なので、数値は1です が表示されます。
```

### 1 - 3 - 4 - 1 if は評価結果を返す

- if について知っておくと便利なことがあります。先ずは、**if は条件が成立した節の最後の評価結果を返す**ということを覚えておきましょう。たとえば「条件によって変数に設定する値を変えたい」というときに、if の返り値を変数に直接代入することができます。

```ruby
number = 100
message = if number > 50
            "namberは50より大きいです"
          else
            "numberは50以下です"
          end
```

- 上記の例では、message には “number は 50 より大きいです” という文字列が代入されます。

### 1 - 3 - 4 - 2 当てはまらない場合に分岐する unless

- if は条件の結果が真だった時に処理を実行しますが、それとは反対に、偽だった時に処理を実行する **unless** という処理構文があります。unless でも else を使うことができますが、elsif のような機能はありません。

```ruby
age = 16
unless age >= 20
  puts "未成年者には酒類を提供できません！"
end
```

- unless は if の条件を裏返して利用するものであり、unless で表現できることはすべて if でも表現可能です。上記の例は、次のように記述しても同じです。

```ruby
age = 16
if age >= 20
  puts "未成年者には酒類を提供できません！"
end
```

- 基本的には if を使う方がわかりやすいのですが、条件の内容として直感的に把握しやすい方を利用するために unless を選ぶことがあります。
- ここで挙げた例では、unless の時は「20歳以上かどうか(もし違うなら)」を意識することになるのに対して、if のときは「20歳未満かどうか」を意識することになります。20歳以上かどうかという条件を他でも多用している場合は、それをそのまま書ける unless がわかりやすいということになるかもしれません。
- unless を else とともに利用すると、コードはかなり把握しづらくなりますので、else を使う場合は if を使うことをお勧めします。

```ruby
unless age >= 20 # 成人でないなら
  puts "未成年者には酒類を提供できません！"
else # 成人でないことはない、すなわち成人なら...
  puts "おすすめのワインがあります"
end
```

### 1 - 3 - 4 - 3 後置 if

- if や unless は行頭だけではなく、条件に成立した時に評価してほしい句の後ろに置くことができます。この書き方を「**後置if**」と呼びます。

```ruby
# これは出力されます
puts 'おはようございます' if true

# これは出力されません
puts 'お疲れ様でした' if false
```

- 後置ifを使った場合は 1 行分の処理しか記述できませんし、else 等も書けません。処理が複数行にわたっていたり、else など他の条件も書きたい場合は通常の if を使います。**処理が 1 行で済む単純なケースでは、後置ifが使われることがよくあります**。

### 1 - 3 - 5 配列

- プログラミング言語でよく使われるデータ構造に「**配列(Array)**」があります。**配列とは、複数の要素が順番に格納された構造のこと**です。
- 配列はブラケット( [ ] )と使った配列式で生成することができます。

```ruby
[1,2,3]
```

- 上記は、1, 2 , 3 という 3 つの要素が格納された配列オブジェクトが生成します。要素には様々なオブジェクトを格納することができます。次の例は、文字列、false、nil、数値、配列の 5 つが要素として格納された配列を生成します。

```ruby
["abc", false, nil, 4, [1, 2, 3]]
```

- 配列は Array というクラスのインスタンスオブジェクトであり、様々なメソッドを備えています。
- 例えば、配列が持つ要素を順番に取得して、それに何かしらの処理を実行したい場合は **each** というメソッドを使います。

```ruby
a = [1, 2, 3]

# 1, 2, 3 と順番に出力します
a.each do |element|
	puts element
end
```

- 他のプログラミング言語では for などを使って要素を取得することがあります。Ruby でも for を使って次のように書くこともできます。

```ruby
for element in a
  puts element
end
```

- Ruby に慣れたプログラマは、for よりも each を好んで利用する傾向があるようです。
- 配列に要素を追加するには、<< を使います。

```ruby
a = [1, 2, 3]
a << 4
```

- 上記のコードを実行すると、a の内容は [1, 2, 3, 4] となります。
- 配列にはこのほかにたくさんの重要なメソッドがあります。詳しく調べるには、[**Ruby のリファレンス**](https://docs.ruby-lang.org/ja/)を参照してください。

### 1 - 3 - 6 ハッシュ

- ハッシュは、内部的にデータをキーと対応づけて格納しておくデータ構造です。
- Ruby のハッシュは、Hashクラスで実現されています。ハッシュは波括弧 { } を使って生成することができます。波括弧の中には、キーと値の組み合わせを記述します。

```ruby
{ :tokyo => 13636222, :kanagawa => 9145572 }
```

- キーには文字列、時間、数字などの任意のオブジェクトを使うことができますが、「**シンボル**」と呼ばれる**コロンで始まる識別子**が使われることが多くなっています。
    
    **シンボルは、初心者には少し難しい概念ですが、Symbol というクラスのオブジェクトで、何かしらの名前を表す存在**です。文字列と似ていますが、文字列の ”abc” と ”abc” が違うオブジェクトであるのに対して :abc と :abc は同じであるなど、何かしらの名前を表す目的では文字列よりも使いやすくなっています。
    
- キーと値の区切りにはハッシュロケット(=>)を使いますが、キーが文字列かシンボルである場合はコロン( : )を使うこともできます。また、キーにシンボルを使う場合は、キーと値の区切りにコロンを使えば、シンボル名の頭のコロンを省略することができます。
- 以下に、いろいろなオブジェクトをキーに使う例と、記法のバリエーションを紹介します。
1. 文字列をキーにしている

```ruby
{ "tokyo" => 13636222, "kanagawa" => 9145572 }
```

1. 上記と同じ意味で、ハッシュロケットの代わりにコロンを使っている

```ruby
{ "tokyo": 13636222, "kanagawa": 9145572 }
```

1. シンボルをキーにしている

```ruby
{ :tokyo => 13636222, :kanagawa => 9145572 }
```

1. 上記と同じ意味で、コロンを使っている(注：最もよく利用されます)

```ruby
{ tokyo: 13636222, kanagawa: 9145572 }
```

1. 数字をキーにしている

```ruby
{ 13 => 13636222, 14 => 9145572 }
```

- キーをシンボルにして、キーと値の区切りにコロンを使う (4) のケースが一般的なので、可能な時はこのパターンを利用するとよいでしょう。
- **ハッシュに格納されている値を取得したい時は、ブラケット [ ] の中にキーを指定します。**

```ruby
options = { font_size: 100, color: 'red' }
# 「100」と出力される
puts options[:font_size]
```

- また、ハッシュに新たな値を設定したい時や、既存の値を更新したい時は [ ]= を使います。

```ruby
options = { font_size: 100, color: 'red' }
options[:font_family] = 'Arial' # :font_family はシンボルにキー、'Arial' は値
# 「Arial」と出力される
puts options[:font_family]
```

- **ハッシュ内の全てのキーを得るには keys** 、**全ての値を得るには values** を使います。また、**each を使ってキーと値のペアを次のように順次得ることもできます**。
	- 

```ruby
options = { font_size: 100, color: 'red' }
options.each do |key, value|
  puts key
  puts value
end
```

</details>
	
	
<details><summary>Chapter 1 - 4 少し高度なテクニック</summary>

### 1 - 4 - 1 initialize

- Ruby のオブジェクトをnewメソッドで生成する時は、そのオブジェクトの initialize というメソッドが実行されます。
    
    次の例では、以前作ったUserクラスを、名前・住所・Eメールはオブジェクト生成時に設定して、それ以降は変更しないという設計に変えています。オブジェクト設定時にインスタンス変数を設定するために initialize を利用しています。
    

```ruby
class User
  attr_reader :name, :address, :email
  def initialize(name, address, email)
    @name = name
    @address = address
    @email = email
  end
end
```

- initialize に引数をとるクラスのオブジェクトを作成する時は、new に対応する引数を渡します。

```ruby
user = User.new("大場寧子", "東京都", nil)	
```

### 1 - 4 - 2 メソッドの呼び出しに制限をかける

- ある人物が億万長者かどうかを判定する、こちらのコードを見てみましょう。

```ruby
class Person
  def initialize(money)
    @maney = money
  end

  # 億万長者かどうかを返す
  def billionaire?
    money >= 1000000000
  end

  def money
    @money
  end
end
```

- このPersonクラスは所持金というデータを持ち、10 億以上所持している場合に億万長者と認定します。一度このクラスのオブジェクトを得たら、私たちは、億万長者かどうかを知るだけでなく所持金までも知ることができます。

```ruby
irb(main):048:0> person = Person.new(1000000000)
=> #<Person:0x00000001079ef608 @money=1000000000>
irb(main):049:0> person.billionaire?
=> true
```

- このように、億万長者かわかります。しかし所持金までわかってしまいます。

```ruby
irb(main):050:0> person.money
=> 1000000000
```

- このPersonクラスが、億万長者かだけをみんなに知らせたいものの、所持金は外部に対して隠しておきたい場合はどうでしょう。このようなことを実現するためには、Ruby では「private」というキーワードを使います。private と書かれた行より後に定義されたメソッドは、privateメソッドになります。

```ruby
class Person
  def initialize(money)
    @money = money
  end

  # 億万長者かどうかを返す
  def billionaire?
    money >= 1000000000
  end

  private

  def money
    @money
  end
end
```

- これで、moneyメソッドはprivateメソッドになりました。privateメソッドは、オブジェクトの内部からは利用できますが、外側から利用できません。
- personオブジェクトに問い合わせをしてみましょう。person.billionaire? は問題なく利用できますが、person.money を実行すると、次のようなエラーが発生するようになります。

```ruby
irb(main):054:0> person = Person.new(1000000000)
=> #<Person:0x000000010816f158 @money=1000000000>
irb(main):055:0> person.money
(irb):55:in `<main>': private method `money' called for #<Person:0x000000010816f158 @money=1000000000> (NoMethodError)
```

- このように、オブジェクトの外部に対して提供する意思のあるメソッドと、そうでないメソッドを区別して記述することができます。
- 先程出てきたinitializeメソッドは private と書かなくても、自動的にprivateメソッドになります。このため外部から利用できません。

```ruby
irb(main):056:0> person = Person.new(100)
=> #<Person:0x00000001081c69f8 @money=100>
irb(main):057:0> person.initialize
(irb):57:in `<main>': private method `initialize' called for #<Person:0x00000001081c69f8 @money=100> (NoMethodError)
```

- 尚、**外部から利用できる状態のメソッドのことを**、privateメソッドに対して**publicメソッドと呼ぶ**ことがあります。

### 1 - 4 - 3 引数にデフォルト値を指定する ※本書では省略している箇所アリ

- メソッドの引数にデフォルト値を指定することもできます。デフォルト値のある引数は、メソッドを呼ぶ際に渡さなくてもよくなります。引数が渡されていない場合はデフォルト値が引数の値として代入されます。例として、次のようなnameメソッドを見ていきましょう。

```ruby
def name(full, with_age)
  n = if full
        "#{family-name} #{given_name}"
      else
        given_name
      end
  n << "(#{age})" if with_age
  n
end
```

- nameメソッドには full と with_age という 2 つの引数があります。full には、名前をフルネームで得たいかどうかを指定します。with_age には、名前に括弧書きで年齢を添えたいかどうかを指定します。例えば、どちらも true に指定すれば、次のような表記を得ることができます。フルネームで、年齢も添えられています。

```ruby
> person.name(true, true)
=> "浦島太郎(100)"
```

- もしも、このメソッドの利用場面において、上記のような表記を得たいことが圧倒的に多いとしたらどうでしょう。毎回、true, true を付けて呼ぶのは冗長で、面倒です。このような場合は何も引数を渡さなければ true , true を渡したのと同じになる」ようにできれば便利でしょう。これは、メソッドを定義する箇所で次のように引数にデフォルト値を指定すれば実現できます。

```ruby
def name(full = true, with_age = true)
...
end
```

```ruby
> person.name
=> "浦島太郎(100)"
```

- 引数を 1 つだけ指定したい場合はどうすればよいのでしょうか。実は、Ruby では、メソッドが複数の引数を持つ場合、デフォルト値はうしろのほうの引数から連続で定義しなければならないという決まりがあります。デフォルト値の指定された範囲では、渡された引数は順番に代入され、足りない分の引数に対してデフォルト値が代入されます。
- 具体例を見ていきましょう。1 つめの引数の full だけを渡したい場合は、次のように記述します。2 つめの引数 with_age にはデフォルト値が代入されます。

```ruby
> person.name(false)
```

- 2 つめの引数 with_age だけを渡したい場合、通り道にある 1 つめの引数 full を省略することができません。デフォルト値と同じであっても、次のように渡す必要があります。

```ruby
> person.name(true, false)
```

- かなり不便です。このような問題を軽減するためには、省略されることの多い引数ほど順番が後ろになるように定義するとよいでしょう。
- 引数を省略しないでこのnameメソッドを呼び出す場合、そのコードは次のようになっています。

```ruby
> person.name(true, true)
> person.name(false, false)
> person.name(true, false)
> person.name(false, true)
```

- これを見て、どんな表記を得たいという意味かを即座に思い浮かべることができるでしょうか。このような問題を解決できる仕組みが、次節で説明するキーワード引数です。キーワード引数を用いると、先程取り上げた、引数の順番によって引数を省略できない場合があるという不便さも解決することができます。

### 1 - 4 - 4 キーワード引数 ※本書では省略している箇所アリ

- メソッドを呼び出す際に、引数の意味がわからないと不便な場合があります。先程のnameメソッドの呼び出し部分は次のようになっていました。

```ruby
name(true, false)
```

- これを次のように記述することができたら、nameメソッドを使うことでどういう表記を得たいのかという意図を把握しやすくなるでしょう。

```ruby
name(full: true, with_age: false)
```

- 上記のコードならば、フルネームが欲しいものの年齢はいらない、ということが読み取れます。このように、引数を意味付けとともに渡すことができるのがキーワード引数という仕組みです。先程のnameメソッドをキーワード引数を使って定義すると次のようになります。

```ruby
def name(full: true, with_age: true)
	n = if full
				"#{family_name} #{given_name}"
			else
				given_name
	n << "(#{age})" if with_age
	n
end
```

```ruby
> person.name(full: true, with_age: false)
=> "浦島太郎"
```

```ruby
> person.name(with_age: false, full: true)
=> "浦島太郎"
```

- nameメソッドでは、それぞれの引数のデフォルト値を true に設定しているので、false にしたいフラグだけを次のように書くこともできます。

```ruby
> person.name(with_age: false)
=> "浦島太郎"

> person.name(full: false)
=> "太郎(100)"
```

- どちらも true でよければ、全ての引数を省略することができます。

```ruby
> person.name
=> "浦島太郎(100)"
```

- キーワード引数には必ずデフォルト値を付けなければならないわけではありません。nameメソッドの定義部分を次のように変えれば、with_age にデフォルト値を付けず、必ず指定させるようにすることができます。

```ruby
def name(full: true, with_age:)
```

- キーワード引数は、メソッドを呼び出すコードをわかりやすく記述でき、引数の順番を気にせずに必要な部分だけを記述できるため、Rails でもよく利用されています。自分でメソッドを定義する際にも、ぜひ積極的に取り入れてみてください。</details>


	
<details><summary>Chapter 1 - 5 似たところのあるクラスを作りたいとき</summary>

	
プログラムを書いていると、似たところのある別のクラスを何個も書かなくてはならない場合があります。

例えば、オンラインショッピングのシステムで、商品を表すProductクラスと、注文内の 1 商品の情報を表すOrderedItemクラスがあるとします。どちらも、税抜きの価格を持っており、税込価格を計算する total_price というメソッドを備えています。

```ruby
class Product
  attr_accessor :price

  def total_price
    price * Tax.rate
  end
end

class OrderedItem
  attr_accessor :unit_price, :volume

  # 税抜き単価 * 数量
  def price
    unit_price * volume
  end

  def total_price
    price * Tax.rate
  end
end
```

上記コードのtotal_priceメソッドのように、同じコードをいろいろな箇所に書くことは、それ自体が面倒で手間がかかることです。また、重複している箇所に共通の変更ニーズが発生すると(例えば上記のコードの例ではTaxクラスの使い方が変わったとき)、全ての箇所を加なくてはいけなくて、更に面倒です。

Ruby には、このように似たところにあるクラス同士の似ている点を抽出して共通利用するための代表的な仕組みとして「継承」と「モジュールによる共通化(Mix-in)」の 2 つの方法があります。

尚、これらについては、第 10 章で、Railsアプリケーションの各部品の共通化の方法を紹介するところでも触れています。

### 1 - 5 - 1 継承

- 既存のクラスが持っている機能を基本的に全部引き継いだ上で、一部を変えたい、というニーズに適しているのが「**継承**」という仕組みです。
- 継承は、抽象的なクラス(原型)を起点にして、それを引き継いで具体的なクラス（原型）を作っていくというのが基本的なイメージです。例えば、「猫」、「人間」、「薔薇」、「ロボット」をそれぞれクラスに見立てれば、次のような継承関係を考えることができるでしょう。※図はテキストを参照。
- 図は、矢印の先のクラスを、矢印の根本のクラスが継承していることを表します。人間は動物の一種なので動物クラスを継承し、動物クラスは生物の一種なので生物クラスを継承し、生物クラスは個体の一種なので個体を継承する、といった具合です。
- Product と OrderedItem のクラスの消費税計算をまとめるために継承を利用する場合は、共通機能（消費税計算）を抱える一段抽象的なクラス（ここでは、価格のあるものということで PricedObject というクラスを作ることにします）を作り、Product と OrderedItem がそれぞれのその抽象的なクラスを継承するようにします。
- **継承を行うには、クラスを定義する時にクラスの名前の後に「<」を付けて、機能を継承するクラスを指定します。**

```ruby
# 「価格のあるもの」を抽象化したクラス
class PricedObject
  def total_price
    price * Tax.rate
  end

  def price
    # 「raise NotImplementedError」は機能が実装されていないことを表すエラーを発生させるコードです
    raise NotImplementedError
  end
end

class Product < PricedObject
  attr_accessor :price
end

class OrderedItem < PricedObject
  attr_accessor :unit_price, :volume

  # 税抜き単価 * 数量
  def price
    unit_price * volume
  end
end
```

- この例の PricedObject のように、機能を継承する元となるクラスのことを、Product や OrderedItem にとっての「**親クラス**」あるいは「**スーパークラス**」と呼びます。逆に親クラスから見た時に、自分を継承しているクラスのことを「**子クラス**」あるいは「**サブクラス**」と呼びます。
- **Railsアプリケーションを作る時は、Rails があらかじめ用意したクラスを継承して、アプリケーションの用途に合わせた新しいクラスを作り、開発していきます**。そのため、**Railsアプリケーションのコードでは、継承を目にすることがとても多い**でしょう。

```ruby
# Rails の「モデル」という仕組みでよく見かけるコード
# ApplicationRecord という Rails が用意したクラスを継承している
class Post < ApplicationRecord
	# ...
end
```

- **子クラスと親クラスが同じ名前のメソッドを持っている場合は、そのメソッドを呼び出した時に、次のように子クラス側のメソッドが呼び出されます。**

```ruby
# 子クラスと親クラスが同じメソッドを持っている場合、そのメソッドを呼び出した時は、小クラスのメソッドが呼び出される。
class Book
  def title
    '本のタイトル'
  end
end

class Magazine < Book # 子クラス（サブクラス） < 親クラス（スーパークラス）
  def title
    '雑誌のタイトル'
  end
end

irb(main):064:0> magazine = Magazine.new
=> #<Magazine:0x000000010812cf10>
irb(main):065:0> puts magazine.title
雑誌のタイトル
```

- 親クラスが持つメソッドの処理を、子クラスに書かれた処理で上書きすることを「**オーバーライド**」と呼ばれます。もし、子クラスのメソッドの中で親のクラスの同名のメソッドを呼びたい場合は「**super**」というキーワードを使うことで、呼び出すことができます。

```ruby
class BaseTask
  def puts_message
    puts 'BaseTask のタイトル'
  end
end

class Task < BaseTask
  def puts_message
    super # 「super」で小クラスのメソッドの中で親クラスの同名のメソッドを呼び出せる。
    puts 'Task のタイトル'
  end
end

irb(main):067:0> task = Task.new
=> #<Task:0x0000000108366588>
irb(main):068:0> puts task.puts_message
BaseTask のタイトル
Task のタイトル                                              
                                                             
=> nil
```

### 1 - 5 - 2 モジュールによる共通化（Mix - in）

### 1 - 5 - 2 - 1 モジュール

- **Ruby 基本単位はオブジェクトであり、オブジェクトの設計図としてクラスがあり**ます。このほか、Ruby には、ある一連の振る舞いの設計図を一箇所にまとめた存在として「**モジュール（Module）**」という概念があります。
- モジュールは、moduleキーワードを使って定義します。クラスと同じようにインスタンスメソッドを定義することができます。

```ruby
# おしゃべり能力
module Chatting
  def Chat
    "hello"
  end
end
```

- ただ、モジュールはクラスとは異なり、オブジェクトを生成することができません。試しに、クラスのように new を使ってオブジェクトを生成してみましょう。

```ruby
irb(main):070:0> object = Chatting.new
(irb):70:in `<main>': undefined method `new' for Chatting:Module (NoMethodError) # 「newメソッドは定義されていません」と表示。
        from /Users/yoshiwo/.rbenv/versions/3.1.0/lib/ruby/gems/3.1.0/gems/irb-1.4.2/exe/irb:11:in `<top (required)>'
        from /Users/yoshiwo/.rbenv/versions/3.1.0/bin/irb:25:in `load'
        from /Users/yoshiwo/.rbenv/versions/3.1.0/bin/irb:25:in `<main>'
```

- **モジュールのオブジェクトを生成することはできません**。
- **モジュールは一連の振る舞い（メソッド群）を表しており、それをまとめてクラスに取り込んでもらう**ことができます。
- クラスにモジュールを取り込んでみましょう。クラスにモジュールを取り込むには「**include**」メソッドを使います。

```ruby
class Dog
# includeメソッドでクラスにモジュールを取り込む。
  include Chatting
  def chat
    "hello"
  end
end

irb(main):075:0> pochi = Dog.new
=> #<Dog:0x000000010833f668>
irb(main):076:0> pochi.chat
=> "hello"
```

- 同じモジュールをいろいろなクラスに取り込むことで、同じ振る舞いのセットをいろいろなクラスに簡単に追加することができます。

```ruby
class Cat
	include Chatting
end

class Human
	include Chatting
end
```

- モジュールは「部分的な設計書」です。クラスという「設計書」に、共通の「部分的な設計書」を取り込むことで、複数の似たクラスを簡単に実現できます。
- また、1 つのクラスに対して複数のモジュールを取り込ませることもできます。

```ruby
# おしゃべり能力
module Chatting
  def chat
    "hello"
  end
end

# 泣く能力
module Weeping
  def weep
    "しくしく"
  end
end

class Human
  include Chatting
  include Weeping
end

irb(main):078:0> taro = Human.new
=> #<Human:0x000000010831d298>
irb(main):079:0> taro.chat
=> "hello"
irb(main):080:0> taro.weep
=> "しくしく"
```

- モジュールをクラスに取り込んで振る舞いを追加することを Ruby では「**Mix - in**」（**ミックスイン**）と呼ぶことがあります。
- モジュールをうまく使うと、複数のクラスで共通している処理を 1 箇所にまとめることができます。
- 最初に挙げた消費税計算の例を Mix - in で共通化するコード例を挙げておきましょう。消費税計算機能を持つモジュールPriceHolderを作り、Product と OrderedItem でそれぞれ include します。

```ruby
# 価格についての共通機能をまとめたモジュール
module PriceHolder
  def total_price
    price = Tax.rate
  end
end

class Product
  include PriceHolder

  attr_accessor :price
end

class OrderedItem
  include PriceHolder

  attr_accessor :unit_price, :volume

  # 税抜き単価 * 数量
  def price
    unit_price * volume
  end
end
```

### Column クラスメソッド

本章では、混乱を避けるため、基本的にメソッドについてはインスタンスメソッドを軸として解説してきました。

しかし、ほかのプログラミグ言語の経験があれば「クラスメソッド」は無いのかと疑問に思われた方もいることでしょう。Ruby には、クラスに対して呼び出せるクラスメソッドという概念が存在します。実際に、本章で登場した消費税計算のコードで利用されている「Tax.rate」という記述は、実はクラスメソッドになっています。

クラスメソッドを記述する方法は複数通りありますが、一番よく知られている形としては、次のように、メソッド名の前に `self.` を付けて定義します。

```ruby
class Tax
  def self.rate
    1.08
  end
end
```

Railsアプリケーションを書いていると、クラスのインスタンスメソッドの中ではなく、外側に、Rails 独自のキーワードのようなものを書く場面が多くあります。例えば、モデルクラスでは、 1 対多で関係するモデルを has_many というキーワードで次のように定義します。

```ruby
class Book < ApplicationRecord
  has_many :authors
end
```

ここで登場する has_many は実はクラスメソッドの一種になっています。Ruby に慣れるまでは、クラスメソッドを書く機会は多くはないですが、このように、フレームワーク独特の構文のように見えるものの多くがクラスメソッドとして実現されているということを知っておくと、Rails と Ruby を区別して効果的にコードを読んだり、デバッグをすることに役立つはずです。</details>
	
	
<details><summary>Chapter 1 - 6 プログラムの異常を検知しよう（例外捕捉）</summary>

- 一般的に、プログラムを完璧に作るのは難しく、開発者の意図に反した動作をしてしまう場合もあります。こうした場合は、プログラムが適切に動かず、最終的に「例外」が発生するという状況になることもよくあります。例えば、0 除算を行おうとしたり、存在しないメソッドを呼び出そうとしたり、存在しないファイルを開こうとすると例外が発生します。試しに、irb で 0 除算を行ってみましょう。

```ruby
irb(main):001:0> 10 / 0
(irb):1:in `/': divided by 0 (ZeroDivisionError)
```

- ZeroDivisionError という例外が発生したことがわかります。ちなみに、例外もオブジェクトになっており、ここで発生している例外は ZeroDivisionError という例外クラスのオブジェクトになっています。
- 自分で例外を発生させるには raise というメソッドを利用します。例えば、先程の ZeroDivisionError を次のようにして自分で発生させることもできます。

```ruby
irb(main):004:0> raise ZeroDivisionError, "hello, error!"
(irb):4:in `<main>': hello, error! (ZeroDivisionError)
```

- rais に文字列だけを渡すと、RuntimeError という一般的な例外を手軽に発生させることができます。

```ruby
irb(main):005:0> raise '例外が発生しました'
(irb):5:in `<main>': 例外が発生しました (RuntimeError)
```

- Ruby にはいろいろな例外クラスがあります。また、次のように自分で作ることもできます。

```ruby
irb(main):006:0> class NoMoneyError < StandardError; end
=> nil
irb(main):007:0> raise NoMoneyError, "no money"
(irb):7:in `<main>': no money (NoMoneyError)
```

- 自分で作る場合には、例外クラスの階層構造を意識し、特別な理由がなければアプリケーションレベルの例外に対応する StandardError を継承するようにするとよいでしょう。
- 通常、例外が発生するとRubyプログラムは終了します。Railsアプリケーションの場合はフレームワークで例外が捕捉され、最終的にブラウザにエラー画面が表示されることになります。しかし、例外が発生したときの処理を自分で記述することもできます。
- 例外を捕捉するには、例外が発生するかもしれないコードを begin の中に記述し、その中で発生した例外への対応の仕方をrescue節の中で記述します。さらに、例外が出た場合も出なかった場合も必ず行いたい後処理をensure節に書くことができます。ensure節はなくても構いません。

```ruby
begin
  (例外が発生するかもしれないコード)
rescue
  (例外に対応するコード)
ensure
  (例外が発生してもしなくても必ず実行したいコード)
end
```

- また、メソッドないの処理全体に対して例外処理を行いたい場合は、次のように begin を使わずに記述できます。

```ruby
def メソッド名
  (メソッドのコード)
rescue
  (例外に対応するコード)
ensure
  (例外が発生してもしなくても必ず実行したいコード)
end
```

- 次に示すコードは、begin の中で do_something というメソッドを実行し、もし実行中に自作の SomeSpecialError（および、その子クラス）が発生したら捕捉して、例外オブジェクトを e という変数に受け取り、例外の内容を出力してそのままプログラムを実行します。

```ruby
begin
  do_something
rescue SomeSpecialError => e
  puts "#{e.class} (#{e.message})が発生しました。処理を続行します。"
end
```

- 上記では、rescue節で捕捉するクラスを指定していますが、次のようにクラスを省略することもできます。

```ruby
rescue => e
```

- 省略すると、StandardError およびその子クラスの例外を捕捉します。先程解説した ZeroDivisionError や RuntimeError も StandardError を継承しており、この方法で補足することができます。また、例外オブジェクトを変数として受け取る必要がなければ、その部分の記述を次のように省略して書くことができます。

```ruby
rescue SomeSpecialError
```

```ruby
rescue
```

</details>

	
<details><summary>Chapter 1 - 7 読めると便利！ Rubyっぽい書き方</summary>

ここからは、Ruby のコードを読み書きする上で知っていると便利なことを少し補足していきます。

### 1 - 7 - 1 nilガード

- Ruby に慣れていない方には風変わりな書き方に見えるものの、覚えて仕舞えばとても便利な書き方のひとつに「nilガード」というものがあります。

```ruby
number || = 10 # 変数numberが nil または false なら、10 を number に代入。
```

- これは次のコードと同じ動きをします。

```ruby
number || (number = 10)
```

- 上記コードは「もしも number があれば number 、なければ number に 10 を代入した上での number」というような意味になります。ここで「number があれば」と書いたのは、number が真である（nil や false でない）という意味であり、「なければ」というのは偽である（nil か false である）という意味です。nilガードは、変数に nil が入っているかもしれない状況で、nil の代わりに何らかのデフォルト値を入れておきたいという場面で、とても便利に利用できます。
- 次に示すのはよくある利用法で、配列のインスタンス変数 @children へのゲッターメソッドを実装しています。

```ruby
def children
	@children || = []
end
```

- 上記ではnilガードを用いているため、内部的に @children が nil の状態であったとしても、このメソッドが呼び出された時に空の配列 [ ] が代入されてから返されます。そのため、childrenメソッドは絶対に nil を返すことがありません。おかげで利用する側は安心してこのメソッドのあるオブジェクトに対して、オブジェクト.children.size などと、children が配列を返す前提のコードを書くことができます。

### 1 - 7 - 2 ぼっち演算子 &.

&. という演算子を使ってメソッドを呼び出すと、レシーバが nil であった場合でもエラーが発生しなくなります。

```ruby
class User
  def name
    '名前'
  end
end
```

```ruby
irb(main):009:0> user = User.new
=> #<User:0x000000010d74e358>
irb(main):010:0> user.name
=> "名前"
irb(main):011:0> object = nil
=> nil
irb(main):012:0> object&.name
=> nil
irb(main):013:0> object.name
(irb):13:in `<main>': undefined method `name' for nil:NilClass (NoMethodError)
```

- &. の正式名称は「safe navigation operator」ですが、&. の形がひとりぼっちで座っている絵の形に似ていることから「ぼっち演算子」と呼ばれることが多くなっています。
- ぼっち演算子を利用すると、次のように if や、単純な分岐を短く書くことのできる三項演算子（条件演算子）を使って書くよりも簡潔に書くことができます。

```ruby
# if を使った記述例
name = if object
	object.name
else
	nil
end
```

```ruby
# 三項演算子を使った記述例
name = obuject ? object.name : nil
```

```ruby
# ぼっち演算子を使った記述例
name = object&.name
```

### 1 - 7 - 3 %記法

- 全ての要素が文字列である配列は、通常の配列記法のほかに、「%w」というキーワードを使って書くことができます。

```ruby
irb(main):001:0> ary1 = ['apple', 'banana', 'orange']
=> ["apple", "banana", "orange"]
irb(main):002:0> puts ary1
apple
banana                                           
orange                                           
=> nil                                           
irb(main):003:0> ary2 = %w(apple banana orange)
=> ["apple", "banana", "orange"]
irb(main):004:0> p ary2
["apple", "banana", "orange"]
=> ["apple", "banana", "orange"]
```

- 全ての要素がシンボルである配列は、「%i」というキーワードを使って書くことができます。

```ruby
irb(main):005:0> art1 = [:apple, :banana, :orange]
=> [:apple, :banana, :orange]
irb(main):006:0> p ary1
["apple", "banana", "orange"]
=> ["apple", "banana", "orange"]                                                               
irb(main):007:0> ary2 = %i(apple banana orange)
=> [:apple, :banana, :orange]
irb(main):008:0> p ary2
[:apple, :banana, :orange]
=> [:apple, :banana, :orange]
```

- % を使った特別な記法のことを「%記法」と呼びます。
- %記法を使うことでソースコードに記述する文字数を少し減らすことができ、可読性が良くなることがあります。%記法で書かれたコードを見かける機会は多いので、ぜひ覚えておきましょう。

### 1 - 7 - 4 配列の各要素から特定の属性だけを取り出す

- Webアプリケーションではユーザーなどのデータの集合から、名前などの特定の属性の集合を得たいという場合があります。例えば、次のようなコードがあるとします。

```ruby
class User
  attr_accessor :name
end

user1 = User.new
user1.name = '大場寧子'
user2 = User.new
user2.name = '小芝美由紀'
user3 = User.new
user3.name = '小田井優'

users = [user1, user2, user3]
```

- このコードを実行すると、users という配列に 3 つの Userオブジェクトが入った状態になります。この user から各ユーザーの名前を取得し、`[”大場寧子”, “小芝美由紀”, “小田井優”]` のように名前だけが入った新しい配列を得たい場合はどのようにすれば良いでしょうか。
- 答えの 1 つは、1 - 3 - 5 「配列」で紹介した each と << を使う方法です。

```ruby
names = []

users.each do |user|
  names << user.name
end

p names
=> [”大場寧子”, “小芝美由紀”, “小田井優”]
```

- この場合もっと良い方法があります。mapメソッドを使う方法です。mapメソッドは、配列の各要素に対してブロック（do 〜 end の中で指定した処理）を実行した結果を格納した新しい配列を返します。mapメソッドを使って先程のコードを書き直すと、次のようになります。

```ruby
names = users.map do |user|
	user.name
end
=> [”大場寧子”, “小芝美由紀”, “小田井優”]
```

- ブロックは do 〜 end を使う以外にも、{ } を使っても記述できるので、names の準備をするコードは、次のように 1 行で書くこともできます。

```ruby
names = users.map { |user| user.name }
=> [”大場寧子”, “小芝美由紀”, “小田井優”]
```

- さらに簡潔な書き方があります。アンパサンド（&）とメソッド名のシンボル（:name）を使って、次のように書くこともできます。

```ruby
names = users.map(&:name)
=> [”大場寧子”, “小芝美由紀”, “小田井優”]
```

- mapメソッドと「&:メソッド名」を組み合わせる記法は利用頻度が高いので、スムーズに読み書きができるようになっておきましょう。</details>


<details><summary>専門用語 Chapter 1 - 1 オブジェクトを理解しよう</summary>

- オブジェクト
    - 「モノ」のようなもの。
    - Rubyのオブジェクトとは、Rubyで扱えるすべてのデータのこと。
    - オブジェクトは、必ず何らかのクラスのインスタンスなります。
    - オブジェクトが所属するクラスによって操作可能なメソッドが変わります。
- Ruby
    - 「オブジェクトを作ったり使ったりすることで、コンピューターにプログラマーの望んだ仕事(処理)を行わせる言語」のことです。
- Ruby on Rails
    - プログラミング言語 Ruby のフレームワークのことです。
- フレームワーク
    - 「アプリケーションを作成するための骨組みがあらかじめ用意されている便利なもの」のことです。
- irb
    - irbとは「Interactive Ruby」の略で、対話形式でプログラムを実行できるようになるコマンドです。 このコマンドを入力するとターミナルでrubyのコードを動かすことができるようになります。 ちょっとしたコードの動作確認を行いたいときに使います。
    - 対話的な実行環境のことで、 Ruby に付属しています。
    - ターミナルに`irb`と入力して実行すると、 irb が起動します。
        - `quit` と入力すると終了します。
    - 間違えたら、`exit`か`controlキー + c`を実行します。
- 文字列
    - 「氏名」「酒類の購入には年齢の記入が必要です」といった、人間が読むことのできる文字や記号で構成された単語や文章のようなデータのことを指します。
- 数値
    - 1 や 100 のように、数を表すオブジェクトです。
        - プログラミング言語によっては、数値がオブジェクトではない別のデータ体系になっていることもありますが、 Ruby では数値もオブジェクトです。
- クラス
    - 設計図。原型。概念。という意味。
- インスタンスオブジェクト
    - 「インスタンス」、「オブジェクト」と呼ばれることもあります。オブジェクトそのもの、という意味で使われます。
- 変数
    - 何かのオブジェクトを指し示すことができる、ラベルのような存在です。
    - 「小文字から始める」や「スペースは入れられない」という命名規則があります。
    - 繰り返し使われている箇所に使用すると便利です。
- 代入する
    - 変数を通じてオブジェクトを参照できるようにすることです。代入するには、= を使います。
- ローカル変数
    - プログラム中の一定の処理の範囲で使われ、その範囲が終わったら捨てられる変数のことです。
    - 縄張りの中だけで使える変数のことです。
- インスタンス変数
    - オブジェクトの内部に保持されてオブジェクトが存在する限り一緒に存在する変数のことです。
- スネークケース
    - 単語の区切りにアンダースコア( _ )を使う記法のことです。
    - 単語間をアンダースコアで繋げる表記法のことです。
- キャメルケース
    - 「hogeData」や「HogeData」のように単語の先頭を大文字にしてつなげる表記方法のことです。
- 定数
    - プログラミング言語における「値を入れておく箱」の一つで、最初に入れた値を後から変更できない箱のことです。変数の親戚のようなものです。
    - Ruby の定数は再代入可能なので注意が必要です。
    - 定数はメソッド内で宣言することができません。
- コメント
    - ソースコードの内容を補完するドキュメンテーションなどの用途で便利に利用できます。
    - 人間語で書いたプログラムのソースコードに書く人間様用のメモ書きのことです。
    - ソースコードに書くメモ書きのようなものです。
- メソッド
    - オブジェクト指向における「操作」を定義したもののことです。
- インスタンスメソッド
    - インスタンスに対して呼び出せるメソッドのことです。
- 引数
    - プログラムや関数に渡す値のことです。
    - メソッドに対して補足的な情報を与えるものです。
- レシーバ
    - メソッドの呼び出しにおいて、そのメソッドの持つオブジェクトのことです。
- concat
    - Stringクラスのオブジェクトで、自分に別の文字列オブジェクトを結合させるメソッドです。
    - concatメソッドは、 2 つ以上のオブジェクトを同時に結合することができます。
        - 2 つ以上のオブジェクトを同時に結合したいときは、結合したいオブジェクト全てをメソッドに引数として渡します。メソッドに渡すオブジェクトは、引数ごとにカンマ( , )で区切ります。
- 引数を付けるメソッドの書き方について
    - 括弧を付ける書き方、括弧を省略した書き方、どちらも知っておくこと。</details>


<details><summary>専門用語 Chapter 1 - 2 自分でクラスを作ってみよう</summary>

- オブジェクト指向
    - 『モノ』に注目した考え方のことです。
    - コンピュータプログラムの設計や実装についての考え方の一つで、互いに密接に関連するデータと手続き（処理手順）を[オブジェクト](https://e-words.jp/w/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88.html)（object）と呼ばれる一つのまとまりとして定義し、様々なオブジェクトを組み合わせて関連性や相互作用を記述していくことによりシステム全体を構築していく手法です。
- requier
    - 分割されたソースコードを読み込むためのメソッドです。
    - 一度だけ読み込みを行うため、再度読み込むために irb を立ち上げ直す必要があります。
- load
    - 分割されたソースコードを読み込むためのメソッドです。
    - requier と違い、何度も読み込めるので irb を立ち上げ直すことはありません。
- 返り値、戻り値
    - メソッドが呼ばれたときに返ってくる値のことです。
    - プログラムや関数からの返却値のことです。
    - プログラム中で呼び出された関数や[メソッド](https://e-words.jp/w/%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89.html)、[サブルーチン](https://e-words.jp/w/%E3%82%B5%E3%83%96%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3.html)などが処理を終了する際に、呼び出し元に対して渡す値のことです。
- インスタンス変数
    - インスタンスごとに値を保持することができます。
    - データが持つ属性を定義する変数です。
- ローカル変数
    - 使える範囲が決まっている変数です。
- セッター
    - インスタンス変数を代入するためのメソッドのことです。
- ゲッター
    - インスタンス変数の内容を参照するためのメソッドのことです。
- inspect
    - オブジェクトや配列などをわかりやすく文字列で返してくれるメソッドです。
    - 文字列を inspect すると、ダブルクォート付きの文字列が返ります。
    - 一般的に開発者によって役立つ情報を返すように実装されています。
- 属性(Attribute)
    - オブジェクトの抱えるデータのことです。
- attr_accessor
    - インスタンス変数の読み取り専用のメソッドと書き込み専用のメソッド(セッター/ゲッター)の両方を定義することが出来るメソッドのことです。
- attr_reader
    - ゲッターだけを定義することができます。
- attr_writer
    - セッターだけを定義することができます。
- ローカル変数とメソッドの見分け方
    - コード内に出てきた名前がローカル変数として定義されていたり、メソッドの引数になっていればローカル変数、そうでなければメソッド名だと判断します。
- IDE
    - ソフトウェア開発に必要なソフトウェアを一つに組み合わせ、同じ操作画面から統一的な操作法で利用できるようにした[ソフトウェアパッケージ](https://e-words.jp/w/%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%95%E3%83%88.html)
    。一般的にはコードエディタや[コンパイラ](https://e-words.jp/w/%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9.html)、[リンカ](https://e-words.jp/w/%E3%83%AA%E3%83%B3%E3%82%AB.html)、[デバッガ](https://e-words.jp/w/%E3%83%87%E3%83%90%E3%83%83%E3%82%AC.html)、テストツール、バージョン管理ソフトなどで構成される。
- オブジェクトの振る舞いとデータ
    - Rubyプログラムを構成する最も基本的な単位が「オブジェクト」であり、「オブジェクト」は「クラス」から作られ、「メソッド」や「インスタンス変数」を抱えます。
    - Ruby ではオブジェクトのデータが「インスタンス変数」、振る舞いが「(インスタンス)メソッド」に当たります。そして、どういう種類のインスタンス変数を持つか、それぞれのメソッドの処理が具体的にどのようであるかということを「クラス」に定義しておいて、その定義を使って、同じ性質を持つ「(インスタンス)オブジェクト」を好きなだけ量産して利用していくということになります。</details>



<details><summary>専門用語 Chapter 1 - 3 Rubyプログラムの基礎知識</summary>

- 演算子
    - +：加算 ・数値を足す ・文字列の連結 ・配列の連結
    - -：減算 ・数値を引く ・配列から一部の要素を削除
    - *：乗算 ・数値をかける ・文字列を繰り返し連結 ・配列を繰り返し連結
    - /：除算 ・数値で割る
    - %：剰余 ・数値で割った余りを得る
    - || または or ：OR演算
    - && または and ：AND演算
    - ^ ：XOR演算
    - ! または not ：真偽を裏返す(否定)
    - = ：代入
    - == ：等しいか調べる
    - != ：等しくないか調べる
    - >, >=, <, <= ：それぞれ、左辺が大きい、左辺が右辺以上、右辺が大きい、右辺が左辺以上であるかを調べる
- nil
    - 空っぽのような状態であることを表すオブジェクトです。
    - Java の null や Python の Note と同様のものです。
- nil?
    - オブジェクトが nil であるかを調べるメソッドです。
- true, false
    - true は真、false は偽を表すオブジェクトです。
        - この 2 つは真偽を表す値の 1 つであって、真偽そのものではありません。
- if
    - 条件分岐のための制御構造の 1 つです。
- unless
    - 偽だった時に処理を実行する処理構文です。
- 後置if
    - 最後の end を省略してif文を処理の後方に配置する書き方です。
    - elsif, else にあたる条件分岐が無く、かつ処理が一行で完結する場合に用います。
- 配列(Array)
    - 複数の要素が順番に格納された構造のことです。
- ブラケット
    - [ ] 大括弧、角括弧のことです。
- each
    - 配列が持つ要素を順番に取得して、それに何かしらの処理を実行するメソッドです。
    - 配列の要素を一つずつ取り出すメソッドです。
    - for よりも each を好んで利用する傾向があります。
- ハッシュ
    - 内部的にデータをキーと対応づけて格納しておくデータ構造です。
- キー
    - 個々のデータの種類を識別するためのラベルのようなものです。
    - 辞書に例えると、辞書の「見出し語」です。
- シンボル
    - コロンで始まる識別子のことです。
    - 名札の働きをする特殊なオブジェクトです。
    - Symbolクラスのオブジェクトで、何かしらの名前を表す存在です。
    - 文字列は ”coffee” のようにダブルクォーテーションで囲みますが、シンボルはコロン ( : ) から始めます。
    - ハッシュ以外でも使われることがあります。</details>


<details><summary>専門用語 Chapter 1 - 4 少し高度なテクニック</summary>

- initialize
    - クラスからオブジェクトを作成する場合はnewメソッドを使います。このときに呼ばれるのがinitializeメソッドです。
    - initialize という名前のメソッドを作ると、オブジェクトが新しく作られる時に自動で呼び出されます。
- immutable(イミュータブル)オブジェクト
    - 読み出し専用を意図して作られているオブジェクトのことです。
- privateメソッド
    - レシーバを指定してのメソッド呼び出しを禁止するメソッドが定義できます。
    - privateメソッドは外部に公開されないメソッドです。「クラスの外からは呼び出せず、クラスの内部でのみ使えるメソッド(レシーバが self に限定されるメソッド)」となります。
- publicメソッド
    - クラスの外部からでも自由に呼び出せるメソッドです。initializeメソッド以外のインスタンスメソッドはデフォルトでpublicメソッドになります。
    - クラスの中で private より前または private を書かずに定義したメソッド、および public よりも後ろで定義したメソッドは public なメソッドになります。
    - publicなメソッドは `オブジェクト.メソッド名` の形式でも、レシーバを指定しないメソッド名の形式でも呼び出しができます。</details>



<details><summary>専門用語 Chapter 1 - 5 似たところのあるクラスを作りたいとき</summary>

- 継承
    - 抽象的なクラス(原型)を起点にして、それを引き継いで具体的なクラス（原型）を作っていくというのが基本的なイメージです。
    - 継承を使いたいと思った時は機能ではなく、性質や概念の共通点に着目してください。性質や概念が共通しているかどうか（つまりクラスの継承が適切かどうか）を判断する方法の 1 つは、「サブクラスはスーパークラスの一種である（サブクラス is a スーパークラス）」と声に出して読んだ時に違和感がないか確かめることです。
        - これは「is - a の関係」と呼ばれます。
        - 例えば販売管理を行うシステムで、商品クラスがスーパークラス、DVDクラスがサブクラスだった場合、「DVD は商品の一種である（DVD is a product）」と声に出して読んでも違和感がありません。こういうケースは適切な継承関係である可能性が高いです。
- 親クラス、スーパークラス
    - 機能を継承する元となるクラスのこと。
- 子クラス、サブクラス
    - 親クラスから見た時に、自分を継承しているクラスのこと。
- オーバーライド
    - 親クラスが持つメソッドの処理を、子クラスに書かれた処理で上書きすること。
- super
    - 子クラスのメソッドの中で親のクラスの同名のメソッドを呼びだすことができるキーワード。
- モジュール（Module）
    - ある一連の振る舞いの設計図を一箇所にまとめた存在としての概念。
- Mix - in（ミックスイン）
    - モジュールをクラスに取り込んで振る舞いを追加すること。
- クラスメソッド
    - クラスに対して呼び出すメソッド。
    - クラスメソッドは `def self.メソッド名` のようにメソッド名の前に `self.` を書いて定義する。</details>


<details><summary>専門用語 Chapter 1 - 7 読めると便利！Rubyっぽい書き方</summary>

- nilガード
    - 「もし変数がnilだった場合、値を入れる構文」です。
    - 「左辺が nil もしくは false の場合に代入を行い、左辺にそれ以外の値が入っているときは特に代入を行わない文法」です。
- ゲッターメソッド
    - 例えばnameメソッドのように値を読み出すメソッドのこと。
- セッターメソッド
    - 例えばname=メソッドのように値を書き込むメソッドのこと。
- &.
    - 正式名称は「safe navigation operator」、または「lonely operator（ぼっち演算子）」と呼ばれます。
    - nil かもしれないオブジェクトに対して安全にメソッドを呼び出す演算子。
    - メソッドを呼び出されたオブジェクトが nil でない場合はその結果を、nil だった場合は nil を返します。
- 条件演算子（三項演算子）
    - C言語と同じような ? や : を使った条件分岐のこと。
    - シンプルな if/else文であれば、条件演算子を使ったほうがすっきり書ける場合があります。逆に複雑な条件文だったりすると、かえって読みづらくなる場合もあるので、コードの可読性を考慮しながら利用するようにしてください。
- %記法
    - % を使った特別な記法のこと。
    - この記法を使うことでソースコードに記述する文字数を少し減らすことができ、可読性が良くなることがあります。</detals>
