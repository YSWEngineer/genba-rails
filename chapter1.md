# Chapter 1 Rails のための Ruby 入門
<details><summary>Chapter 1 - 1 オブジェクトを理解しよう</summary>
	
### 万物がオブジェクト
- Ruby や Ruby on Rails を理解する上で、いちばんの基礎となるのが「オブジェクト」という概念です。
- 「オブジェクト」とは、簡単に言うと「モノ」のようなものです。
- Ruby の世界には、大小のオブジェクトが関わり合いながら存在しています。
    - 別の言い方をすると、Ruby は「オブジェクトを作ったり使ったりすることで、コンピューターにプログラマの望んだ仕事(処理)を行わせる言語」です。
- Ruby の世界の中の「オブジェクト」と見分けて、どのオブジェクトがどんな仕事を担当するのかをイメージできるようになることが大切です。
- Ruby on Rails と使って Webアプリケーションを書くということは、Rails の用意したフレームワークを理解して、その上でプログラムを書くということでもあります。


### irb
- Ruby には、irb (アイアールビー)という、対話的な実行環境が付属しています。


### 文字列
- Webアプリケーションにおいてもっとも基本的なオブジェクトの一つが「文字列」です。
- 文字列とは、「氏名」「酒類の購入には年齢記入が必要です」といった、人間が読むことのできる文字や記号で構成された単語や文章のようなデータのことを指します。
- 文字列オブジェクトを作る一番簡単な方法は、ダブルクォーテーション(”)で内容を囲むことです。たとえば、`”氏名”`のように書きます。
- 文字列オブジェクトを作るためには、シングルクォーテーション(’)を使うこともできます。


### 数値
- プログラムを作る上では、数値も重要です。
- 数値とは、 1 や 100 のように、数を表すオブジェクトです。
- Ruby では数値もオブジェクトに含まれます。


### オブジェクトに、自分が何者かを聞いてみる
- 全てのオブジェクトには、自分の型を持っていて、この型のことを「クラス」と呼びます。
- クラスを尋ねるには、オブジェクトの後に `.class` という記述をします。

```bash
irb(main):001:0> "氏名".class
=> String # String(文字列)
```

```bash
irb(main):002:0> 1.class
=> Integer # Integer(整数)
```

- オブジェクトは全てが object_id という固有の番号を持っています。
    
```bash
irb(main):001:0> "氏名".object_id
=> 11300
irb(main):002:0> 1.object_id
=> 3
irb(main):003:0> "氏名".object_id
=> 27880
irb(main):004:0> 1.object_id
=> 3
```
    
- “氏名” という Rubyコードに対応して用意される文字列オブジェクトは、Rubyコードが実行されるたびに、別のオブジェクトが作られる。
- 1というRubyコードに対応して用意される数値オブジェクトは、何回 1 というRubyコードを実行しても、同じ数値オブジェクトが提供される。


### クラスとインスタンス
- Rubyのようなオブジェクト指向言語では、一般的に「オブジェクト X のクラスが A であるとき、X は A のインスタンス(オブジェクト)である」といいます。
- インスタンスオブジェクトは「インスタンス」、「オブジェクト」と呼ばれることもありますが、オブジェクトそのもの、という意味で使われます。


### オブジェクトの機能はクラスで決まる
- オブジェクトにどんな仕事をさせることができるのかは、そのオブジェクトがどんなクラスのオブジェクトであるかによります。
- オブジェクトの機能はクラスによって異なるので、Ruby でプログラムを作るためには、どんなクラスのオブジェクトにどんな機能があるのかを知り、目的にあったクラスのオブジェクトを使うことが大切になってきます。


### 変数
- 変数は、何かのオブジェクトを指し示すことができる、ラベルのような存在です。変数にわかりやすい名前を付けて使うことで、プログラムを格段にわかりやすくすることができます。
- 変数を通じてオブジェクトを参照できるようにすることを「代入する」と呼びます。代入するには、= を使います。
- Ruby のローカル変数の名前は、アルファベットの小文字かアンダースコア( _ )で始めます。2 文字目以降には、大文字や数字も利用できます。慣習としては、単語の区切りにアンダースコア( _ )を使うスネークケースという記法で変数の名前を付けることが好まれています。


| よく見かける記法 | 文法的にはあっているが、一般的でない記法 | ローカル変数として解析できない記法 |
| --- | --- | --- |
| sample_message | sampleMessage (キャメルケース) | SampleMessage |
| part2 | パート2 | 2part |
| _user | _USER | -user |

- なお、アルファベットの大文字から始まる名前は、保持する値が不変の「定数」と解釈されます。厳密には、Ruby の定数の値は絶対に変更できないわけでなく、warningメッセージが出力されるものの、再定義することも可能となっています。


### コメント
- Ruby のプログラムの中に、任意のコメントを記述することができます。コメントは、ソースコードの内容を補完するドキュメンテーションなどの用途で便利に利用できます。
- いくつか書き方はありますが、基本的なのが # のあとにコメントを記述する方法です。


### メソッド
- オブジェクトの代表的な仕事は、何らかの振る舞いをすることです。Ruby のオブジェクトの振る舞いは、基本的に「メソッド」として記述します。
    - メソッドには「(〜を)…します」というような内容を記述することになります。

```ruby
タマ.追いかける(ネズミ) 
# 「追いかける」がメソッドに相当します。
# インスタンスに対して呼び出せるメソッドをインスタンスメソッドと呼びます。
```

- インスタンスに対して呼び出せるメソッドをインスタンスメソッドと呼びます。

```ruby
class 猫
  def 追いかける(ネズミ)
	puts "一生懸命 #{ネズミ} を追いかけた..." # 画面にメッセージを出力します。
  end
end

タマ = 猫.new
# 「追いかける」の部分がメソッド、(ネズミ)の部分がメソッドに対して補足的な情報を与える「引数」と呼ばれるものになります。
```

- 「追いかける」の部分がメソッド、(ネズミ)の部分がメソッドに対して補足的な情報を与える「引数」と呼ばれるものになります。
- オブジェクトにドット( . )を付け、その後にメソッドの名前を記述することでメソッドを呼び出すことができます。

```ruby
# フォームから入力されたデータが変数に入っている状態を作ります。
message = '先ほど注文した商品を全て一旦キャンセルさせてください'

# エラーメッセージの表示を行います。
if message.length > 100
  puts 'メッセージは100文字以下で入力してください。'
end
```

- 先の lengthメソッドの呼び出し例では、message がレシーバとなっています。
- Stringクラスのオブジェクトには、 concat という、**自分に別の文字列オブジェクトを結合させるメソッド**があります。

```ruby
irb(main):005:0> message1 = "こんにちは。"
=> "こんにちは。"
irb(main):006:0> message2 = "こんばんは。"
=> "こんばんは。"
irb(main):007:0> message1.concat(message2)
=> "こんにちは。こんばんは。"
irb(main):008:0> message1
=> "こんにちは。こんばんは。"
irb(main):009:0> message2
=> "こんばんは。"
```

- concatメソッドは 2 つ以上のオブジェクトを同時に結合することができます。2 つ以上のオブジェクトを同時に結合したいときは、結合したいオブジェクトを全てをメソッドに引数として渡します。メソッドに渡すオブジェクトは、引数ごとにカンマ( , )で区切ります。

```ruby
irb(main):011:0> message1 = "おはようございます。"
=> "おはようございます。"
irb(main):012:0> message2 = "こんにちは。"
=> "こんにちは。"
irb(main):013:0> message3 = "こんばんは。"
=> "こんばんは。"
irb(main):014:0> message1.concat(message2, message3)
=> "おはようございます。こんにちは。こんばんは。"
```

- 引数を付けるメソッドには必ず括弧を付けていました。しかし、実は**括弧を省略してメソッド呼び出しを書く**こともできます。括弧を省略する時は、メソッド名と引数の間に半角スペースを入れます。

```ruby
irb(main):015:0> message1 = "おはようございます。"
=> "おはようございます。"
irb(main):016:0> message2 = "こんにちは。"
=> "こんにちは。"
irb(main):017:0> message3 = "こんばんは。"
=> "こんばんは。"
irb(main):018:0> message1.concat message2,message3
=> "おはようございます。こんにちは。こんばんは。"
```

- 括弧を省略しない書き方、省略した書き方、どちらの書き方も実際のコードを読んでいて見掛けることがあります。慣れるまでは大変かもしれませんが、どちらの書き方も知っておくと便利です。
    - なお、引数を渡す必要がないメソッドを length( ) のように空の括弧に付けて呼び出すこともできますが、Rubyプログラマの間では、length のように括弧を付けない書き方が主流と言えそうです。</details>


<details><summary>Chapter 1 - 2 自分でクラスを作ってみよう</summary>
	
### クラスを作る
- Ruby on Rails で Webアプリケーションを作る場合には、プログラマがクラスを作成する必要があるため、クラスを作ることについての知識は欠かせません。


### Userクラスを作る
- ユーザーを表すクラスを作成します。

    1\. user.rbフォルダを作成する。
    
    2\. エディターを開いて、user.rb フォルダから user.rbファイルを作成する。
    
    3\. user.rbファイルに、User という名前のクラスを作成する。

```ruby
# エディターに User という名前のクラスを作成する。
class User
end
```

```ruby
# require を使って user.rb を読み込みます。
irb(main):001:0> require './user.rb'
=> true

# クラスの名前の後に .new と記述して、オブジェクトを作成します。
irb(main):002:0> user = User.new
=> #<User:0x000000010a623fd0>

# Userクラスのオブジェクトが作られたかどうか、レシーバのクラス名を返すclassメソッドを使って、確認します。
irb(main):003:0> user.class
=> User # user はUserクラスのオブジェクトになっています。
```

### Userクラスにメソッドを定義する
- 作成したUserクラスから name というメソッドを作成します。

```ruby
# エディター
class User
  def name
  end
end

# irb
irb(main):001:0> require './user.rb'
=> true
irb(main):002:0> user = User.new
=> #<User:0x000000010b31d970>
irb(main):003:0> user.name
=> nil
```

- nil は Ruby において「無い」ことを表すオブジェクトです。nameメソッドは空っぽなので、nil が返ってきています。
- メソッドが呼ばれたときに返ってくる値のことを「返り値(または戻り値)」と呼びます。Ruby では、return を使って明示的に指定された値や、メソッド内で最後に評価された値がメソッドの返り値となります。どちらを使っても構いませんが、一般的には、メソッドの途中でメソッドを抜けたい場合には return を使い、メソッドの最後で返り値を指定する場合は return を使わないことが多いでしょう。
- たとえば、どんなユーザーの name も”匿名さん”を返すようにしたい場合は、nameメソッドの実装は次のようになります。

```ruby
# return を使う場合
class User
  def name
    return "匿名さん"
  end
end

# return を使わない場合
class User
  def name
     "匿名さん"
  end
end
```

- どちらの書き方でも、次のように、Userクラスのオブジェクトでnameメソッドの返り値として「匿名さん」という文字列を得ることができます。

```ruby
irb(main):002:0> user = User.new
=> #<User:0x0000000112cf3b00>
irb(main):003:0> user.name
=> "匿名さん"
```

- 実際には、すべてのUserオブジェクトが同じ名前を持つように実装することはほとんどないでしょう。ログインしてきたユーザーそれぞれの名前を保持するようにしたいはずです。オブジェクトごとに異なるデータを保持できるようにするためには、「インスタンス変数」を使います。


### インスタンス変数
- インスタンス変数は、オブジェクトが抱えている変数です。インスタンス変数に代入したデータは、インスタンス変数を抱えているオブジェクトが存在する限り、オブジェクトともに存在し続けます。インスタンス変数は、オブジェクトのメソッドの中から利用可能な一方で、オブジェクトの外側から直接利用することは基本的にできません。インスタンス変数の名前の先頭には必ず＠(アットマーク)を付けます。

```ruby
class User
  def name=(name)
    @name = name
  end

  def name
    @name
  end
end
```

- ここでは「name=」という名前を設定するメソッドを追加しました。**Ruby では末尾に=という記号がついたメソッド名を定義することで、属性をオブジェクトにセットするような形のメソッドを作ることができます。**name=メソッドでは、引数で受け取ったデータをインスタンス変数 @name に代入します。このような、インスタンス変数を代入するためのメソッドをセッターと呼ぶことがあります。
- また、nameメソッドの中身を変更して、設定した名前(@name)を返すようにしています。このような、インスタンス変数の内容を参照するためのメソッドをゲッターと呼ぶことがあります。
- 新しいUserクラスの動作を確認してみましょう。

```ruby
irb(main):002:0> user = User.new
=> #<User:0x0000000107d89a70>
irb(main):003:0> user.name = "小田井優"
=> "小田井優"
```

- 上記では、名前の文字列をuserオブジェクトに設定しました。続いて、userオブジェクトの状態を見てみましょう。**irb 上でオブジェクトを評価すると、そのオブジェクトのinspectメソッドが呼ばれます。**

```ruby
irb(main):004:0> user
=> #<User:0x0000000107d89a70 @name="小田井優"> # userオブジェクトがinspectメソッドで出力されます。
```

- 設定した名前をuserオブジェクトが「抱えている」様子がわかります。次に、nameメソッドを使って名前を取得してみましょう。

```ruby
irb(main):005:0> user.name
=> "小田井優"
```

- これで、オブジェクトごとに異なる名前を保持することができるようになったので、複数のオブジェクトにそれぞれ違う名前を設定してみましょう。

```ruby
irb(main):007:0> user1 = User.new
=> #<User:0x0000000107d51080>
irb(main):008:0> user1.name = "大場寧子"
=> "大場寧子"

irb(main):009:0> user2 = User.new
=> #<User:0x0000000107d236f8>
irb(main):010:0> user2.name = "小芝美由紀"
=> "小芝美由紀"

irb(main):011:0> user1.name
=> "大場寧子"

irb(main):012:0> user2.name
=> "小芝美由紀"
```

- 無事、オブジェクトごとに別々の名前を入れて扱うことができるようになりました。


### ローカル変数とインスタンス変数の違い
- user のようなローカル変数と @name のようなインスタンス変数は、代入の仕方や参照の仕方は同じですが、次のような違いがあります。
- たとえば、自分で作った次のMyClassクラスが存在するとします。

```ruby
class MyClass
  def method_1
    number = 100
  end

  def method_2
    number
  end
end
```

- このクラスのオブジェクトを作って、method_1メソッドを呼び出してみます。

```ruby
irb(main):014:0> object = MyClass.new
=> #<MyClass:0x0000000107df8218>
irb(main):015:0> object.method_1
=> 100
```

- このメソッドは number というローカル変数に 100 という数値のオブジェクトを入れており、ローカル変数に入れたオブジェクトを返り値としています。
- 続けて、method_2メソッドを呼び出してみます。

```ruby
irb(main):016:0> object.method_2
/Users/yoshiwo/Desktop/user.rb/user.rb:7:in `method_2': undefined local variable or method `number' 
for #<MyClass:0x0000000107df8218> (NameError)
```

- method_1で定義した number というローカル変数が method_2 でも生き残っていれば 100 と表示されるはずです。エラーが返ってきてしまったということは、method_2 では method_1 で使った number を使えない状態だということです。
- それでは、number というローカル変数ではなく、インスタンス変数 @number を使うようにするとどうなるでしょうか。

```ruby
# インスタンス変数 @number を使用。
class MyClass
  def method_1
    @number = 100
  end

  def method_2
    @number
  end
end

irb(main):021:0> object = MyClass.new
=> #<MyClass:0x0000000107bd9310>
irb(main):022:0> object.method_1
=> 100
irb(main):023:0> object.method_2
=> 100
```

- エラーが出ずに、無事に 100 という値が返ってきました。method_1 と method_2 が、同じ @number という変数を利用できていることがわかります。
- ローカル変数とインスタンス変数の違いの理解は、Railsアプリケーションを作成する上でも非常に重要になります。ローカル変数は 1 つのメソッドの中で一時的に使うデータを参照するために使います。一方、インスタンス変数は、特定のオブジェクトの内部で使い回したり、そのオブジェクトに属するデータとして外部からゲッターを通じて利用させるために用います。ここでは、**インスタンス変数はオブジェクトに抱えられたデータである**というイメージを覚えておいてください。


### 属性
- 一般的にオブジェクトの抱えるデータのことを「属性(Attribute)」と呼ぶことがあります。先程の例で言えば、name は user の属性ということになります。インスタンス変数も、オブジェクトの抱えるデータのことですから、属性とインスタンス変数はとてもよく似た概念と言えます。ただし、必ずしも同じではありません。インスタンス変数という用語が Ruby の言語の機能を指しているのに対して、属性という用語はもう少し抽象的に、結果としてオブジェクトに対して読んだり書いたりできる(時には片方しかできない)データを表す概念です。
    
    たとえば、外部から見たときには属性として使わないような、オブジェクト内の”秘密の”インスタンス変数が存在する場合もあります。また、外部の記憶装置などを直接使ったり、固定値や、計算値を用いることで、インスタンス変数を使わないで属性を実現することもできます。
    
    Railsアプリケーションにおいては、特にモデル層でこの「属性」という用語が登場します。Railsモデルの「属性」にはデータベースのカラムとの対応関係などの要素が加わるため、より複雑になりますが、根本的な意味としてはオブジェクトが抱えるデータであることに変わりはありません。「属性」という用語にぜひ慣れておきましょう。


### ゲッターやセッターを簡単に定義する
- 先程は、Userクラスに属性の name のゲッターとセッターを次のように定義していました。

```ruby
class User
  def name=(name)
    @name = name
  end

  def name
    @name
  end
end
```

- ゲッターやセッターの書き方はいつも同じようになり、上記コードの name のところを別の属性名に変えて、機械的に記述することができます。
- 実は Ruby には、このような機械的なコードをプログラマが書かなくても済むように、**attr_accessor** という便利なメソッドが用意されています。先程のコードは attr_accessor を使って次のように書くことができます。

```ruby
class User
	attr_accessor :name
end
```

- ここで渡している :name という部分は、シンボルです。ここでは名前の先頭に : を付けたものがシンボルという存在であるということを覚えておいてください。
    
    なお、attr_readerを使うとゲッターだけ、attr_writerを使うとセッターだけを定義することができます。


### メソッドからメソッドを使う

- オブジェクトのメソッドの中から、同じオブジェクトの他のメソッドを呼び出すことができます。例として、名前と住んでいる場所を合わせて返すようなprofileメソッドを作ってみましょう。

```ruby
class User
  attr_accessor :name, :address, :email

  def profile
    "#{name} (#{address})"
  end
end
```

- `"#{name} (#{address})"` という書き方は見慣れないかもしれません。ダブルクォーテーションで囲んで文字列を作成する際に、#{ } という表記の中でRubyコードを実行し、結果をその位置に埋め込むことができます。

```ruby
irb(main):029:0> user = User.new
=> #<User:0x0000000107cebb18>
irb(main):030:0> user.name = "小田井優"
=> "小田井優"
irb(main):031:0> user.address = "東京"
=> "東京"
irb(main):032:0> user.profile
=> "小田井優 (東京)"
```

- profile というメソッドの内部で、同じオブジェクトの別のメソッドである name や address を呼び出すことができました。
- 因みに、シングルクォーテーションを使って同様の埋め込みはできません。次の実行例で示すように、#{ などがそのまま文字の一部として扱われてしまいます。

```ruby
irb(main):033:0> name = "小田井優"
=> "小田井優"
irb(main):034:0> "#{name}"
=> "小田井優"
irb(main):035:0> '#{name}'
=> "\#{name}"
```

- Ruby に慣れていないうちは、メソッド内での name や address が、メソッドの呼び出しなのか、ローカル変数なのか、どちらなのかわからなくて混乱するかもしれません。見分け方としては、**コード内に出てきた名前がローカル変数として定義されていたり、メソッドの引数になっていればローカル変数、そうでなければメソッド名だと判断**できます。
- 1 つ 1 つのメソッドを長大にせず、引数や変数名を妥当につけていけば、実際にコードを読み書きしていて困ることはあまりないと思います。また、**IDE** では変数やメソッドの文字を自動で色分けしてくれるため、簡単に把握することもできます。

### まとめ - オブジェクトの振る舞いとデータ

- これまで、Rubyプログラムを構成する最も基本的な単位が「オブジェクト」であり、「オブジェクト」は「クラス」から作られること、「メソッド」や「インスタンス変数」を抱えることを学んできました。
- 大雑把に言えば、Ruby ではオブジェクトのデータが「インスタンス変数」、振る舞いが「(インスタンス)メソッド」に当たります。そして、どういう種類のインスタンス変数を持つか、それぞれのメソッドの処理が具体的にどのようであるかということを「クラス」に定義しておいて、その定義を使って、同じ性質を持つ「(インスタンス)オブジェクト」を好きなだけ量産して利用していくということになります。
- クラス、オブジェクト、メソッド、インスタンス変数の理解は特に重要なので、よく覚えておきましょう。</details>


<details><summary>Chapter 1 - 3 Rubyプログラムの基礎知識</summary>

ここからは、メソッドを書くといった Ruby でのプログラミングの際によく利用する基本的な Ruby の記法や機能を紹介していきます。

### 1 - 3 - 1 演算子

| 記号 | 意味 |
| --- | --- |
| + | 加算 ・数値を足す ・文字列の連結 ・配列の連結 |
| - | 減算 ・数値を引く ・配列から一部の要素を削除 |
| * | 乗算 ・数値をかける ・文字列を繰り返し連結 ・配列を繰り返し連結 |
| / | 除算 ・数値で割る |
| % | 剰余 ・数値で割った余りを得る |
| || または or | OR演算 |
| && または and | AND演算 |
| ^ | XOR演算 |
| ! または not | 真偽を裏返す(否定) |
| = | 代入 |
| == | 等しいか調べる |
| != | 等しくないか調べる |
| >, >=, <, <= | それぞれ、左辺が大きい、左辺が右辺以上、右辺が大きい、右辺が左辺以上であるかを調べる |
- 数値の演算をするRubyコードの例を挙げておきましょう。

```ruby
irb(main):036:0> result = 1 + 2 * 4 / 8
=> 2
```

- 掛け算や割り算は、足し算や引き算よりも先に評価されるため、上のコードでは 2 という結果が得られます。

### 1 - 3 - 2 nil

- 空っぽのような状態であることを表す「nil」というオブジェクトがあります。nil と書けばいつでも使えます。

```ruby
value = nil
```

- オブジェクトが nil であるかを、nil? というメソッドで調べることができます。

```ruby
irb(main):039:0> value = nil
=> nil
irb(main):040:0> value.nil?
=> true
```

### 1 - 3 - 3 真偽

- if などの条件分岐では、条件が真である(当てはまる)か、それとも偽である(当てはまらない)かで、どのプログラムコードを実行するかを制御します。条件が真であるということはどういうことでしょうか。
- 直感的にわかりやすいのは、次のような例です。

```ruby
value = 3
if value == 3
  # valueが3のとき、ここを実行します。
end
```

- value という変数の値は 3 ですから、「value == 3」は真であるということになります。
- 真か偽という結果は、== などの実行結果だけではなく、オブジェクトそのものを評価しても得られます。

```ruby
value = 3
if value
  # valueが真のとき、ここを実行します。
end
```

- 上記のコードでは、value の値は 3 ですが、これは Ruby では「真」であると解釈されます。
- 真か偽かをわかりやすく示したい場合、Ruby では **true** と **false** というオブジェクトがあり、いつでも利用できます。**true は真、false は偽を表すオブジェクト**です。

```ruby
value = true
if value
  # valueが真のとき、ここを実行します。
end
```

- Ruby では、**nil と false が偽**、それ以外が真となります。
- プログラミング言語の中には 0 が偽である言語もありますが、**Ruby では 0 も真になる**ので注意しましょう。

```ruby
value = 0
if value
  # ここを通ります！
end
```

- nil? を使う例と、偽かどうかを調べている例を挙げておきます。

```ruby
# nil? を使う例
return if value.nil? # value が nil なら以降の処理をしない。

# 偽かどうかを調べている例
return if !value # value が nil もしくは false なら以降の処理をしない。
```

### 1 - 3 - 4 条件分岐

- if の後に条件式を記述して、その条件が真と評価された時にその下の節の処理を実行します。もし、if の条件式が偽だと評価された時は、elseif の条件の評価に進みます。elsif は無くてもよいし、複数記述しても構いません。if と elsif の条件式が全て偽であった時は、else の処理を実行します。else は無くても構いません。最後に「end」でif構造を閉じます。

```ruby
number = 1
if number == 1
  puts '数値は1です'
elsif number == 2
  puts '数値は2です'
else
  puts '数値は1や2以外です'
end

# number == 1 が真なので、数値は1です が表示されます。
```

### 1 - 3 - 4 - 1 if は評価結果を返す

- if について知っておくと便利なことがあります。先ずは、**if は条件が成立した節の最後の評価結果を返す**ということを覚えておきましょう。たとえば「条件によって変数に設定する値を変えたい」というときに、if の返り値を変数に直接代入することができます。

```ruby
number = 100
message = if number > 50
            "namberは50より大きいです"
          else
            "numberは50以下です"
          end
```

- 上記の例では、message には “number は 50 より大きいです” という文字列が代入されます。

### 1 - 3 - 4 - 2 当てはまらない場合に分岐する unless

- if は条件の結果が真だった時に処理を実行しますが、それとは反対に、偽だった時に処理を実行する **unless** という処理構文があります。unless でも else を使うことができますが、elsif のような機能はありません。

```ruby
age = 16
unless age >= 20
  puts "未成年者には酒類を提供できません！"
end
```

- unless は if の条件を裏返して利用するものであり、unless で表現できることはすべて if でも表現可能です。上記の例は、次のように記述しても同じです。

```ruby
age = 16
if age >= 20
  puts "未成年者には酒類を提供できません！"
end
```

- 基本的には if を使う方がわかりやすいのですが、条件の内容として直感的に把握しやすい方を利用するために unless を選ぶことがあります。
- ここで挙げた例では、unless の時は「20歳以上かどうか(もし違うなら)」を意識することになるのに対して、if のときは「20歳未満かどうか」を意識することになります。20歳以上かどうかという条件を他でも多用している場合は、それをそのまま書ける unless がわかりやすいということになるかもしれません。
- unless を else とともに利用すると、コードはかなり把握しづらくなりますので、else を使う場合は if を使うことをお勧めします。

```ruby
unless age >= 20 # 成人でないなら
  puts "未成年者には酒類を提供できません！"
else # 成人でないことはない、すなわち成人なら...
  puts "おすすめのワインがあります"
end
```

### 1 - 3 - 4 - 3 後置 if

- if や unless は行頭だけではなく、条件に成立した時に評価してほしい句の後ろに置くことができます。この書き方を「**後置if**」と呼びます。

```ruby
# これは出力されます
puts 'おはようございます' if true

# これは出力されません
puts 'お疲れ様でした' if false
```

- 後置ifを使った場合は 1 行分の処理しか記述できませんし、else 等も書けません。処理が複数行にわたっていたり、else など他の条件も書きたい場合は通常の if を使います。**処理が 1 行で済む単純なケースでは、後置ifが使われることがよくあります**。

### 1 - 3 - 5 配列

- プログラミング言語でよく使われるデータ構造に「**配列(Array)**」があります。**配列とは、複数の要素が順番に格納された構造のこと**です。
- 配列はブラケット( [ ] )と使った配列式で生成することができます。

```ruby
[1,2,3]
```

- 上記は、1, 2 , 3 という 3 つの要素が格納された配列オブジェクトが生成します。要素には様々なオブジェクトを格納することができます。次の例は、文字列、false、nil、数値、配列の 5 つが要素として格納された配列を生成します。

```ruby
["abc", false, nil, 4, [1, 2, 3]]
```

- 配列は Array というクラスのインスタンスオブジェクトであり、様々なメソッドを備えています。
- 例えば、配列が持つ要素を順番に取得して、それに何かしらの処理を実行したい場合は **each** というメソッドを使います。

```ruby
a = [1, 2, 3]

# 1, 2, 3 と順番に出力します
a.each do |element|
	puts element
end
```

- 他のプログラミング言語では for などを使って要素を取得することがあります。Ruby でも for を使って次のように書くこともできます。

```ruby
for element in a
  puts element
end
```

- Ruby に慣れたプログラマは、for よりも each を好んで利用する傾向があるようです。
- 配列に要素を追加するには、<< を使います。

```ruby
a = [1, 2, 3]
a << 4
```

- 上記のコードを実行すると、a の内容は [1, 2, 3, 4] となります。
- 配列にはこのほかにたくさんの重要なメソッドがあります。詳しく調べるには、[**Ruby のリファレンス**](https://docs.ruby-lang.org/ja/)を参照してください。

### 1 - 3 - 6 ハッシュ

- ハッシュは、内部的にデータをキーと対応づけて格納しておくデータ構造です。
- Ruby のハッシュは、Hashクラスで実現されています。ハッシュは波括弧 { } を使って生成することができます。波括弧の中には、キーと値の組み合わせを記述します。

```ruby
{ :tokyo => 13636222, :kanagawa => 9145572 }
```

- キーには文字列、時間、数字などの任意のオブジェクトを使うことができますが、「**シンボル**」と呼ばれる**コロンで始まる識別子**が使われることが多くなっています。
    
    **シンボルは、初心者には少し難しい概念ですが、Symbol というクラスのオブジェクトで、何かしらの名前を表す存在**です。文字列と似ていますが、文字列の ”abc” と ”abc” が違うオブジェクトであるのに対して :abc と :abc は同じであるなど、何かしらの名前を表す目的では文字列よりも使いやすくなっています。
    
- キーと値の区切りにはハッシュロケット(=>)を使いますが、キーが文字列かシンボルである場合はコロン( : )を使うこともできます。また、キーにシンボルを使う場合は、キーと値の区切りにコロンを使えば、シンボル名の頭のコロンを省略することができます。
- 以下に、いろいろなオブジェクトをキーに使う例と、記法のバリエーションを紹介します。
1. 文字列をキーにしている

```ruby
{ "tokyo" => 13636222, "kanagawa" => 9145572 }
```

1. 上記と同じ意味で、ハッシュロケットの代わりにコロンを使っている

```ruby
{ "tokyo": 13636222, "kanagawa": 9145572 }
```

1. シンボルをキーにしている

```ruby
{ :tokyo => 13636222, :kanagawa => 9145572 }
```

1. 上記と同じ意味で、コロンを使っている(注：最もよく利用されます)

```ruby
{ tokyo: 13636222, kanagawa: 9145572 }
```

1. 数字をキーにしている

```ruby
{ 13 => 13636222, 14 => 9145572 }
```

- キーをシンボルにして、キーと値の区切りにコロンを使う (4) のケースが一般的なので、可能な時はこのパターンを利用するとよいでしょう。
- **ハッシュに格納されている値を取得したい時は、ブラケット [ ] の中にキーを指定します。**

```ruby
options = { font_size: 100, color: 'red' }
# 「100」と出力される
puts options[:font_size]
```

- また、ハッシュに新たな値を設定したい時や、既存の値を更新したい時は [ ]= を使います。

```ruby
options = { font_size: 100, color: 'red' }
options[:font_family] = 'Arial' # :font_family はシンボルにキー、'Arial' は値
# 「Arial」と出力される
puts options[:font_family]
```

- **ハッシュ内の全てのキーを得るには keys** 、**全ての値を得るには values** を使います。また、**each を使ってキーと値のペアを次のように順次得ることもできます**。
	- 

```ruby
options = { font_size: 100, color: 'red' }
options.each do |key, value|
  puts key
  puts value
end
```

</details>
	
	
<details><summary>Chapter 1 - 4 少し高度なテクニック</summary>
